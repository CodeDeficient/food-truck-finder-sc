# SC Food Truck Finder - Development Work Breakdown Structure (WBS)

This document provides a detailed Work Breakdown Structure (WBS) for the implementation phase of the SC Food Truck Finder web application. Phase 1 (MVP) will focus on migrating an existing HTML/CSS/JS prototype (`index.html`) into a robust Next.js application, enhancing it with a proper component structure, state management, and backend foundations. This WBS is derived from the `planning/planning_phase_plan.md` and `prd.txt`. Each task includes a checklist placeholder for tracking completion.

## Phase 1: Minimum Viable Product (MVP) - Vibe Code Focus & Migration (Risk: 4/10 - Overall MVP risk, moderate due to migration complexity and multiple new tech integrations) (Complexity: 6/10 - Migration and integration of disparate parts into a new framework is inherently complex)
P1.0. [ ] **Umbrella Task:** Coordinate and oversee Phase 1 MVP development. (Risk: 4/10 - Overall coordination) (Complexity: 3/10 - Project management aspect, tracking decomposed tasks)

### 1. UI/UX Implementation (Migrating Existing Theme & Structure into Next.js) (Risk: 5/10 - Migration of UI can be tricky, ensuring fidelity across new framework) (Complexity: 6/10 - Involves careful translation of styles and structure, component breakdown)
1.0.  [ ] **Umbrella Task:** Oversee UI/UX migration and component development. (Risk: 5/10 - Ensuring visual and functional parity) (Complexity: 3/10 - High-level oversight of decomposed UI tasks)

**1.1. Next.js Project Setup & Tailwind CSS Integration** (Risk: 3/10 - Standard setup, but migration adds slight complexity) (Complexity: 4/10 - Involves multiple configuration files and understanding Next.js/Tailwind interplay)
1.1.1. [ ] **Action:** Initialize a new Next.js project (App Router, TypeScript recommended, using Bun as primary package manager). (Risk: 2/10 - Standard CLI operation, minor variable for Bun usage) (Complexity: 2/10 - Standard command execution with specified package manager)
    1.1.1.1.  [ ] : Execute `bunx create-next-app` (or `npx create-next-app --use-bun`) and select options (TypeScript, Tailwind CSS, ESLint, App Router, `src/` directory if preferred) (Primary Package Manager: Bun; Fallback: pnpm). (Risk: 1/10 - Following prompts) (Complexity: 1/10 - Interactive setup)
1.1.2. [ ] **Action:** Establish and document chosen package manager (Primary: Bun; Fallback: pnpm). (Risk: 2/10 - Process and documentation) (Complexity: 2/10 - Clear documentation of choice)
    1.1.2.1.  [ ] : Ensure `bun.lockb` (or `bun.lock` if text format becomes default and is used) is the primary lockfile and committed to version control. (Risk: 1/10 - Standard practice) (Complexity: 1/10 - File check and git add)
    1.1.2.2.  [ ] : Document basic Bun commands for the project (`bun install`, `bun add`, `bun run <script>`). (Risk: 1/10 - Simple documentation) (Complexity: 1/10 - Listing commands)
1.1.3. [ ] **Action:** Integrate Tailwind CSS (from `index.html` CDN & custom styles). (Risk: 4/10 - Requires careful config and style porting) (Complexity: 5/10 - Requires understanding of Tailwind config, PostCSS, and Next.js specifics)
    1.1.3.1.  [ ] : Verify `tailwindcss`, `postcss`, `autoprefixer` are in `package.json` (installed via Bun). (Risk: 1/10) (Complexity: 1/10)
    1.1.3.2.  [ ] : Create `tailwind.config.js` and `postcss.config.js` (if not generated by `create-next-app`). (Risk: 2/10) (Complexity: 2/10 - File creation and basic structure)
    1.1.3.3.  [ ] : Configure `tailwind.config.js` `content` paths. (Risk: 2/10) (Complexity: 3/10)
    1.1.3.4.  [ ] : Add custom theme colors to `tailwind.config.js` `theme.extend.colors`. (Risk: 2/10) (Complexity: 2/10)
    1.1.3.5.  [ ] : Configure 'Inter' font using `next/font/google` and `tailwind.config.js`. (Risk: 3/10) (Complexity: 3/10 - Font import, CSS var, Tailwind config)
1.1.4. [ ] **Action:** Migrate existing CSS styles from `index.html`'s `<style>` tag to `src/app/globals.css` and component-specific styles (CSS Modules), addressing potential conflicts with Tailwind CSS. (Risk: 5/10 - Tedious, potential for style/specificity conflicts, ensuring styles apply correctly, managing CSS load order) (Complexity: 6/10 - Careful extraction, conflict resolution, potential refactoring, strategic use of Tailwind layers and CSS Modules)
    1.1.4.1.  [ ] : Review existing styles in `index.html` and categorize them: (Risk: 3/10) (Complexity: 3/10)
        1.1.4.1.1. [ ] : Identify truly global styles (e.g., base body styles, global typography, some layout resets not covered by Tailwind Preflight).
        1.1.4.1.2. [ ] : Identify component-specific styles (e.g., styles for `.truck-card`, `.filter-button`).
        1.1.4.1.3. [ ] : Identify utility-like styles that could be replaced by Tailwind utilities.
    1.1.4.2.  [ ] : Plan CSS load order and specificity management strategy. (Risk: 4/10) (Complexity: 4/10)
        1.1.4.2.1. [ ] : Import `globals.css` in `src/app/layout.tsx` (or root layout file).
        1.1.4.2.2. [ ] : Ensure Tailwind's directives (`@tailwind base; @tailwind components; @tailwind utilities;`) are correctly placed in `globals.css` (typically at the top) to allow custom global styles to override or extend them if necessary.
        1.1.4.2.3. [ ] : For component-specific styles, plan to use CSS Modules (`.module.css`) to avoid class name collisions and scope styles locally.
        1.1.4.2.4. [ ] : If custom global styles need to override Tailwind utilities in specific, rare cases, consider using higher specificity selectors or custom Tailwind layers (e.g. `@layer customGlobal`). Use `!important` as a last resort and document its use.
    1.1.4.3.  [ ] : Migrate global styles to `src/app/globals.css`. (Risk: 4/10) (Complexity: 4/10)
        1.1.4.3.1. [ ] : Transfer `body` styles, verify against Tailwind's Preflight, and resolve conflicts (e.g., by removing redundant styles or adjusting custom styles to complement Preflight).
        1.1.4.3.2. [ ] : Transfer custom scrollbar styles and any other truly global utility classes (e.g., SVG helper classes if broadly used).
    1.1.4.4.  [ ] : Iteratively migrate component-specific styles: For each component identified in Task 1.2 (e.g., `FoodTruckCardComponent`, `FilterButtonComponent`): (Risk: 5/10) (Complexity: 5/10 - Repetitive but requires care for each component)
        1.1.4.4.1. [ ] : Create a corresponding CSS Module file (e.g., `FoodTruckCard.module.css`).
        1.1.4.4.2. [ ] : Transfer its specific styles (e.g., `.truck-card`, `.filter-button`) from `index.html` (or the temporary `globals.css` holding area) to its CSS Module.
        1.1.4.4.3. [ ] : Import and use these module styles in the respective React component.
        1.1.4.4.4. [ ] : During this transfer, actively refactor styles to use Tailwind utility classes where a direct 1-to-1 or simple combination of utilities can achieve the same result. Document styles that are too complex for immediate refactoring.
        1.1.4.4.5. [ ] : Verify styling and resolve any conflicts with Tailwind utilities or global styles. Test responsiveness.
    1.1.4.5.  [ ] : Specifically address `.glass-panel` styles: (Risk: 4/10) (Complexity: 4/10)
        1.1.4.5.1. [ ] : Determine if `.glass-panel` is a global utility or component-specific. If global, consider adding its definition to `globals.css` (potentially under `@layer components` if it's a common pattern). If mostly tied to cards, it might go into `FoodTruckCard.module.css` or a shared card style module.
        1.1.4.5.2. [ ] : Migrate its styles, including the pseudo-element, ensuring it works with Tailwind.
    1.1.4.6.  [ ] : Specifically address `#map` styles: (Risk: 3/10) (Complexity: 3/10)
        1.1.4.6.1. [ ] : These are likely specific to the `MapDisplayComponent`. Migrate to `MapDisplay.module.css` or apply inline if very simple and dynamic.
    1.1.4.7.  [ ] : Ensure Tailwind's JIT engine correctly scans all files for utility classes by verifying `tailwind.config.js` `content` paths (e.g., `['./src/app/**/*.{js,ts,jsx,tsx,mdx}', './src/components/**/*.{js,ts,jsx,tsx,mdx}']`). (Risk: 2/10) (Complexity: 1/10)
    1.1.4.8.  [ ] : Document any complex custom CSS that remains, the rationale for keeping it, and any potential future refactoring opportunities. (Risk: 2/10) (Complexity: 2/10)
1.1.5. [ ] **Action:** Create Tailwind utility classes or components for consistent rounded corners and shadows (leveraging findings from CSS migration, potentially using `@apply` in `globals.css` or a base component style). (Risk: 3/10) (Complexity: 4/10 - May involve creating custom Tailwind plugins or higher-order components, or defining reusable classes with `@apply`)
    1.1.5.1.  [ ] : Review migrated `.glass-panel` styles and other elements for common shadow/corner patterns. (Risk: 2/10) (Complexity: 2/10)
    1.1.5.2.  [ ] : Define and implement new utility classes in `globals.css` via `@layer utilities` if needed. (Risk: 3/10) (Complexity: 3/10)
1.1.6. [ ] **Action:** Research and plan implementation for checkerboard patterns (Lower priority). (Risk: 4/10) (Complexity: 5/10 - If implemented, could involve complex CSS or SVG generation)
    1.1.6.1.  [ ] : Research CSS techniques for checkerboard patterns. (Risk: 3/10) (Complexity: 3/10)
    1.1.6.2.  [ ] : Research SVG-based checkerboard patterns. (Risk: 3/10) (Complexity: 3/10)
    1.1.6.3.  [ ] : Document findings and decide on approach if pursued. (Risk: 2/10) (Complexity: 2/10)

**1.2. Core UI Component Development (Refactoring from `index.html`)** (Risk: 5/10 - Refactoring existing HTML/JS into React components requires careful thought for structure and state) (Complexity: 7/10 - Core migration work, breaking down monolithic HTML into logical, stateful/stateless React components, managing props and interactions)
1.2.1. [ ] **Action:** Develop reusable React components by refactoring `index.html` structure and styles. (Risk: 5/10) (Complexity: 7/10 - Umbrella for component creation)
    1.2.1.1.  [ ] : `HeaderComponent.tsx`: Replicate `<header>` from `index.html`. (Risk: 4/10) (Complexity: 5/10 - Combining structure, styles, and child components)
        1.2.1.1.1. [ ] : Create `HeaderComponent.tsx` with basic JSX structure from `index.html` header. (Risk: 2/10) (Complexity: 2/10)
        1.2.1.1.2. [ ] : Integrate `SearchInputComponent` into `HeaderComponent`. (Risk: 2/10) (Complexity: 2/10)
        1.2.1.1.3. [ ] : Implement SVG icons (hamburger, profile) as inline or separate components. (Risk: 2/10) (Complexity: 3/10)
        1.2.1.1.4. [ ] : Apply Tailwind classes and global styles for header appearance. (Risk: 3/10) (Complexity: 3/10)
    1.2.1.2.  [ ] : `SearchInputComponent.tsx`: For header search. (Risk: 3/10) (Complexity: 3/10)
    1.2.1.3.  [ ] : `BottomNavComponent.tsx`: Replicate `<nav>` from `index.html`. (Risk: 4/10) (Complexity: 5/10 - Similar to Header, involves layout and child components)
        1.2.1.3.1. [ ] : Create `BottomNavComponent.tsx` with basic JSX structure from `index.html` nav. (Risk: 2/10) (Complexity: 2/10)
        1.2.1.3.2. [ ] : Map over navigation link data to render `NavigationItemComponent` instances. (Risk: 3/10) (Complexity: 3/10)
        1.2.1.3.3. [ ] : Apply Tailwind classes and global styles. (Risk: 3/10) (Complexity: 3/10)
    1.2.1.4.  [ ] : `NavigationItemComponent.tsx`: For bottom navigation links. (Risk: 3/10) (Complexity: 3/10)
    1.2.1.5.  [ ] : `FilterBarComponent.tsx`: Replicate structure for cuisine filters. (Risk: 4/10) (Complexity: 5/10 - Managing scrollable layout and button group)
        1.2.1.5.1. [ ] : Create `FilterBarComponent.tsx` with scrollable container. (Risk: 2/10) (Complexity: 3/10)
        1.2.1.5.2. [ ] : Map over filter categories to render `FilterButtonComponent` instances. (Risk: 3/10) (Complexity: 3/10)
    1.2.1.6.  [ ] : `FilterButtonComponent.tsx`: Using styles from `.filter-button`. (Risk: 3/10) (Complexity: 4/10 - Handling click events, dynamic styling based on state)
    1.2.1.7.  [ ] : `TruckListComponent.tsx`: Container for rendering `FoodTruckCardComponent`s. (Risk: 3/10) (Complexity: 4/10 - Iterating over data, passing props to children)
    1.2.1.8.  [ ] : `FoodTruckCardComponent.tsx`: Refactor `createTruckCard()` imperative JS logic into a declarative React component using JSX, driven by props and state. (Risk: 5/10) (Complexity: 6/10 - Involves careful translation of imperative DOM manipulation and event handling to declarative React patterns, managing props, internal state (if any), and potential component breakdown for maintainability)
        1.2.1.8.1. [ ] : Define a clear props interface for `FoodTruckCardComponent` (e.g., `truckData: TruckInfoType`, `onClick: () => void`). (Risk: 2/10) (Complexity: 2/10 - Ensures type safety and clear contract)
        1.2.1.8.2. [ ] : Analyze the existing `createTruckCard()` JS logic:
            1.2.1.8.2.1. [ ] : Identify all DOM elements created and their attributes. Map these to JSX elements. (Risk: 2/10) (Complexity: 3/10)
            1.2.1.8.2.2. [ ] : Identify how data (name, cuisine, status, description, icons) is inserted into the DOM. Plan to pass this data via props and render declaratively (e.g., `{props.truckData.name}`). (Risk: 3/10) (Complexity: 3/10)
            1.2.1.8.2.3. [ ] : Identify any conditional logic (e.g., showing "Open" vs "Closed" status). Plan to implement this using React's conditional rendering (e.g., `{truck.isOpen ? <OpenBadge /> : <ClosedBadge />}`). (Risk: 3/10) (Complexity: 3/10)
            1.2.1.8.2.4. [ ] : Identify any event listeners (e.g., click on card). Plan to implement these using React's synthetic event handlers (e.g., `onClick={props.onClick}`). (Risk: 2/10) (Complexity: 2/10)
        1.2.1.8.3. [ ] : Implement the main JSX structure for `FoodTruckCardComponent` based on the analysis. Avoid direct DOM manipulation (e.g., `document.createElement`, `appendChild`, `innerHTML`, `dangerouslySetInnerHTML`). (Risk: 4/10) (Complexity: 4/10 - Core translation to JSX)
        1.2.1.8.4. [ ] : Implement dynamic data display using props. Ensure all data passed to DOM elements are valid HTML attributes (e.g., avoid passing complex objects directly to a `div`'s props if they are not meant to be attributes). (Risk: 3/10) (Complexity: 3/10)
        1.2.1.8.5. [ ] : Integrate SVG icons (from `truckSvgIcons.ts` or similar) as React components (e.g., `<StarIcon />`) or inline JSX SVGs, rather than manipulating SVG strings imperatively. (Risk: 3/10) (Complexity: 3/10)
        1.2.1.8.6. [ ] : Apply styling using Tailwind CSS utility classes primarily. For complex or repeated styles not easily achievable with utilities, use CSS Modules (`FoodTruckCard.module.css`) and `@apply` if necessary. (Risk: 3/10) (Complexity: 3/10)
        1.2.1.8.7. [ ] : If the card has internal state (e.g., hover effects not manageable by CSS, expanded view), manage this using `useState`. (Risk: 3/10) (Complexity: 3/10)
        1.2.1.8.8. [ ] : Consider breaking down the `FoodTruckCardComponent` into smaller sub-components if it becomes too large or complex (e.g., `CardHeader`, `CardBody`, `CardFooter`, `IconGroup`). (Risk: 3/10) (Complexity: 3/10 - Improves maintainability)
        1.2.1.8.9. [ ] : Test the component thoroughly with various `truckData` inputs to ensure correct rendering, behavior, and styling. (Risk: 3/10) (Complexity: 2/10)
    1.2.1.9.  [ ] : `MapDisplayComponent.tsx` (Placeholder, see 3.1). (Risk: 2/10) (Complexity: 1/10)

### 2. Mobile-First & Responsive Layout Implementation (Risk: 4/10 - Ensuring existing responsiveness translates well to components) (Complexity: 5/10 - Requires testing across devices and ensuring component-based structure maintains responsiveness)
2.0.  [ ] **Umbrella Task:** Oversee and test responsive layout implementation. (Risk: 4/10) (Complexity: 3/10 - Coordination and testing oversight)

**2.1. Responsive Layouts** (Risk: 4/10 - Verification and potential adjustments) (Complexity: 5/10 - Applying responsive design principles consistently across components)
2.1.1. [ ] **Action:** Apply mobile-first design principles (verifying existing responsiveness). (Risk: 4/10) (Complexity: 5/10 - Systematic review and adaptation of styles)
    2.1.1.1.  [ ] : Review and define base mobile styles for each new component. (Risk: 3/10) (Complexity: 3/10)
    2.1.1.2.  [ ] : Verify Tailwind responsive prefixes (`sm:`, `md:`) are correctly applied in components. (Risk: 2/10) (Complexity: 2/10)
2.1.2. [ ] **Action:** Utilize Tailwind's responsive prefixes for breakpoint-specific overrides. (Risk: 3/10) (Complexity: 3/10)
    2.1.2.1.  [ ] : Test layouts on Chrome/Edge/Firefox dev tools for various screen sizes. (Risk: 3/10) (Complexity: 3/10)
    2.1.2.2.  [ ] : (If possible) Test on at least one physical mobile device. (Risk: 2/10) (Complexity: 3/10)
2.1.3. [ ] **Action:** Implement/Verify main layout structures for responsiveness. (Risk: 4/10) (Complexity: 5/10 - Ensuring major layout blocks adapt correctly)
    2.1.3.1.  [ ] : Verify `HeaderComponent` responsiveness (e.g., search bar truncation/wrapping). (Risk: 3/10) (Complexity: 3/10)
    2.1.3.2.  [ ] : Verify Main Content area reflow (map/list stacking vs. side-by-side). (Risk: 4/10) (Complexity: 3/10)
    2.1.3.3.  [ ] : Verify `BottomNavComponent` fixed positioning on mobile. (Risk: 3/10) (Complexity: 3/10)
2.1.4. [ ] **Action:** Ensure interactive elements have sufficient touch target sizes. (Risk: 3/10) (Complexity: 3/10)

### 3. Core Functional Requirements (MVP) (Adapting `index.html` JS logic) (Risk: 6/10 - Integrating JS logic into React/Next.js, especially with external libraries like Leaflet, can be complex) (Complexity: 7/10 - Porting imperative JS to declarative React, managing state, and integrating third-party libraries in Next.js)
3.0.  [ ] **Umbrella Task:** Oversee functional requirement migration and integration. (Risk: 6/10) (Complexity: 3/10 - Coordination of functional parts)

**3.1. Map View Integration (React-Leaflet)** (Risk: 6/10 - Leaflet in React/Next.js can have SSR issues, custom icons and dynamic data add complexity. Leaflet's direct DOM manipulation requires careful client-side handling in Next.js App Router.) (Complexity: 7/10 - Client-side library in Next.js, dynamic rendering, custom markers, state interaction, CSS management, ref handling)
3.1.1. [ ] **Action:** Integrate Leaflet.js via **React-Leaflet** into the Next.js application, ensuring client-side rendering and proper CSS handling. (Risk: 5/10) (Complexity: 6/10 - Setting up library, global CSS, dynamic import for client-side only rendering, and handling Leaflet's browser API dependencies)
    3.1.1.1.  [ ] : Install `leaflet`, `react-leaflet`, and their TypeScript types (`@types/leaflet`). (Risk: 1/10) (Complexity: 1/10)
    3.1.1.2.  [ ] : Import Leaflet's CSS (`leaflet.css`) globally. (Risk: 2/10) (Complexity: 2/10)
        3.1.1.2.1. [ ] : Import `leaflet/dist/leaflet.css` in the root layout file (e.g., `src/app/layout.tsx`) or the main global CSS file (`src/app/globals.css`). Verify correct path and application.
    3.1.1.3.  [ ] : Create the primary map component (e.g., `MapDisplayComponent.tsx`) as a Client Component. (Risk: 4/10) (Complexity: 4/10 - Correctly using `"use client";`, default export, and structuring for dynamic import)
        3.1.1.3.1. [ ] : Add `"use client";` directive at the top of `MapDisplayComponent.tsx`. (Risk: 1/10) (Complexity: 1/10)
        3.1.1.3.2. [ ] : Ensure `MapDisplayComponent.tsx` uses a default export (e.g., `export default function MapDisplayComponent(...)`). (Risk: 1/10) (Complexity: 1/10)
        3.1.1.3.3. [ ] : Implement the basic structure of `MapDisplayComponent` using React-Leaflet components like `<MapContainer>`, `<TileLayer>`.
    3.1.1.4.  [ ] : Dynamically import `MapDisplayComponent` into its parent Server Component (or page) with SSR disabled. (Risk: 4/10) (Complexity: 3/10)
        3.1.1.4.1. [ ] : Use `next/dynamic` for the import: `const DynamicMap = dynamic(() => import('../components/MapDisplayComponent'), { ssr: false, loading: () => <p>Loading map...</p> });`. Ensure the import path is explicit. (Risk: 3/10) (Complexity: 2/10)
        3.1.1.4.2. [ ] : Render `<DynamicMap />` in the parent component.
    3.1.1.5.  [ ] : Verify basic Leaflet map rendering within the dynamically imported component, confirming no SSR-related errors (e.g., `window is not defined`). (Risk: 3/10) (Complexity: 2/10)
    3.1.1.6.  [ ] : If direct access to the Leaflet map instance via `ref` on `<MapContainer>` is needed, research and implement the correct approach for `next/dynamic` components (e.g., using `forwardRef` in `MapDisplayComponent` if necessary, or handling potential proxy refs). (Risk: 4/10) (Complexity: 4/10)
3.1.2. [ ] **Action:** Initialize the map within `MapDisplayComponent.tsx` with base layers and settings. (Risk: 3/10) (Complexity: 4/10 - Using React-Leaflet components and props correctly)
    3.1.2.1.  [ ] : Implement `<MapContainer>` with appropriate props for `center`, `zoom`, `scrollWheelZoom`, and `style` (e.g., `height: '100%'`). (Risk: 2/10) (Complexity: 3/10)
    3.1.2.2.  [ ] : Add `<TileLayer>` for CartoDB Dark Matter. (Risk: 2/10) (Complexity: 2/10)
3.1.3. [ ] **Action:** Implement dynamic marker creation from Zustand store. (Risk: 4/10) (Complexity: 5/10 - Looping, state access, creating multiple map elements)
    3.1.3.1.  [ ] : Access `foodTrucksData` from Zustand in `MapDisplayComponent`. (Risk: 2/10) (Complexity: 2/10)
    3.1.3.2.  [ ] : Map `foodTrucksData` to `<Marker>` components within `<MapContainer>`. (Risk: 3/10) (Complexity: 3/10)
3.1.4. [ ] **Action:** Implement custom SVG icons for map markers using `L.divIcon`, ensuring client-side instantiation and proper styling/anchoring. (Risk: 5/10) (Complexity: 6/10 - SSR pitfalls with Leaflet's icon classes, correctly forming `L.divIcon` options with SVG strings, and precise CSS for anchoring/sizing)
    3.1.4.1.  [ ] : Import/access SVG icon strings (e.g., from a dedicated `truckSvgIcons.ts` or as imported string variables). (Risk: 1/10) (Complexity: 1/10)
    3.1.4.2.  [ ] : Within the client-side `MapDisplayComponent.tsx` (or a helper function called only on the client-side, e.g., inside `useEffect` or render path of this client component):
        3.1.4.2.1. [ ] : Define a function that takes SVG string and any dynamic properties (e.g., color) to generate an `L.divIcon` instance. (Risk: 4/10) (Complexity: 4/10)
            3.1.4.2.1.1. [ ] : Inside this function, create `L.divIcon` options:
                3.1.4.2.1.1.1. [ ] : Set `html` to the SVG string (potentially with dynamic parts interpolated if needed).
                3.1.4.2.1.1.2. [ ] : Set `className` to a custom class (e.g., `custom-svg-marker`) for styling the container of the SVG.
                3.1.4.2.1.1.3. [ ] : Define `iconSize` (e.g., `[width, height]`) matching the SVG dimensions.
                3.1.4.2.1.1.4. [ ] : Define `iconAnchor` (e.g., `[width/2, height]`) to correctly position the icon's point over the map coordinate (typically bottom-center).
                3.1.4.2.1.1.5. [ ] : Define `popupAnchor` (e.g., `[0, -height]`) to position popups relative to the icon.
        3.1.4.2.2. [ ] : (Alternative/Optimization) If icon definitions are static per component instance, consider using `useMemo` within `MapDisplayComponent` to create and memoize `L.divIcon` instances to prevent re-creation on every render, ensuring `L` (Leaflet global) is only accessed on client.
    3.1.4.3.  [ ] : Apply the generated `L.divIcon` instance to each `<Marker>`'s `icon` prop. (Risk: 3/10) (Complexity: 3/10)
    3.1.4.4.  [ ] : Use CSS (e.g., in `globals.css` or a CSS Module for `MapDisplayComponent`) to style the `custom-svg-marker` class if needed (e.g., for `background: transparent`, `border: none`). (Risk: 2/10) (Complexity: 2/10)
    3.1.4.5.  [ ] : Thoroughly test and verify correct visual appearance, size, and anchoring of custom SVG icons for various map zoom levels and interactions (e.g., popup opening). Adjust `iconAnchor` and `popupAnchor` as needed. (Risk: 4/10) (Complexity: 3/10)
3.1.5. [ ] **Action:** Implement basic popups for markers using React-Leaflet's `<Popup>` component. (Risk: 3/10) (Complexity: 3/10)
    3.1.5.1.  [ ] : Nest `<Popup>` component inside `<Marker>` with truck details. (Risk: 2/10) (Complexity: 2/10)
3.1.6. [ ] **Action:** Validate and refine TypeScript types for React-Leaflet components, props, and Leaflet-specific objects like icon options. (Risk: 3/10) (Complexity: 3/10 - Ensuring type safety with Leaflet/React-Leaflet, especially for `L.divIcon` options)
    3.1.6.1.  [ ] : Review types used for map props, marker positions, icon options, and event handlers. (Risk: 2/10) (Complexity: 2/10)
    3.1.6.2.  [ ] : Utilize types from `@types/leaflet` where appropriate to resolve warnings or errors. (Risk: 2/10) (Complexity: 2/10)

**3.2. Scrollable List View & Filtering (React & Zustand)** (Risk: 4/10 - State management and component interaction) (Complexity: 5/10 - Connecting UI elements to state and re-rendering lists)
3.2.1. [ ] **Action:** Render the list of food truck cards in `TruckListComponent.tsx`. (Risk: 3/10) (Complexity: 4/10 - Consuming state and mapping to components)
    3.2.1.1.  [ ] : `TruckListComponent` to consume `foodTrucks` and `activeFilter` from Zustand. (Risk: 3/10) (Complexity: 3/10)
    3.2.1.2.  [ ] : Implement client-side filtering logic in `TruckListComponent`. (Risk: 2/10) (Complexity: 3/10)
    3.2.1.3.  [ ] : Map filtered list to `FoodTruckCardComponent` instances. (Risk: 2/10) (Complexity: 2/10)
3.2.2. [ ] **Action:** Implement filtering logic in `FilterBarComponent.tsx`. (Risk: 4/10) (Complexity: 5/10 - Managing multiple filter buttons and their state interaction)
    3.2.2.1.  [ ] : `FilterButtonComponent` to receive `cuisine` and `isActive` props. (Risk: 2/10) (Complexity: 2/10)
    3.2.2.2.  [ ] : `FilterButtonComponent` onClick to call `setFilter` action from Zustand. (Risk: 3/10) (Complexity: 3/10)
    3.2.2.3.  [ ] : `FilterBarComponent` to determine `isActive` prop based on Zustand state. (Risk: 3/10) (Complexity: 3/10)

**3.3. Data Management (Zustand, migrating from `index.html`)** (Risk: 4/10 - Setting up new state management and migrating data) (Complexity: 4/10 - Defining store structure, actions, and migrating existing data)
    *(s for this section, if any were previously unnumbered, would start at 3.3.1)*

### 4. Security Foundation (Risk: 5/10 - Firebase setup and security rules require care) (Complexity: 5/10 - Understanding Firebase services, config, and security rule syntax)
4.0.  [ ] **Umbrella Task:** Oversee Firebase setup and security configuration. (Risk: 5/10) (Complexity: 3/10 - Coordination)

**4.1. Firebase Project Setup** (Risk: 3/10) (Complexity: 3/10)
    *(s for this section, if any were previously unnumbered, would start at 4.1.1)*

**4.2. Initial Firestore Setup** (Risk: 4/10) (Complexity: 5/10 - Data modeling and writing security logic)
4.2.1. [ ] **Action:** Define initial Firestore collections and document structures (e.g., `trucks`, `schedules`). Avoid sensitive info in document/collection IDs; use non-sequential, randomly generated IDs. (Risk: 4/10) (Complexity: 4/10)
4.2.2. [ ] **Action:** Write and thoroughly test basic Firebase Security Rules for MVP, focusing on default deny and principle of least privilege. (Risk: 5/10) (Complexity: 6/10 - Understanding rule syntax, implications, ensuring no unintended access, and setting up robust local testing)
    4.2.2.1.  [ ] : Configure `firestore.rules` file. Ensure a "default deny" rule is effectively in place (e.g., `match /{document=**} { allow read, write: if false; }` as a final catch-all or by ensuring all paths are explicitly covered by more specific rules that deny by default). (Risk: 3/10) (Complexity: 2/10)
    4.2.2.2.  [ ] : Draft rules for the `trucks` collection:
        4.2.2.2.1. [ ] : Allow public read access to individual truck documents (`/trucks/{truckId}`). (e.g., `allow get: if true;`) (Risk: 2/10) (Complexity: 2/10)
        4.2.2.2.2. [ ] : Allow public list access to the `trucks` collection. (e.g., `allow list: if true;`) (Risk: 2/10) (Complexity: 2/10)
        4.2.2.2.3. [ ] : Deny all write access (create, update, delete) to the `trucks` collection for unauthenticated users and for MVP (data loaded manually or via admin script). (e.g., `allow write: if false;`) (Risk: 3/10) (Complexity: 2/10)
    4.2.2.3.  [ ] : Draft rules for the `schedules` collection (assuming similar public read, no public write model for MVP):
        4.2.2.3.1. [ ] : Allow public read access to individual schedule documents. (Risk: 2/10) (Complexity: 2/10)
        4.2.2.3.2. [ ] : Allow public list access to the `schedules` collection. (Risk: 2/10) (Complexity: 2/10)
        4.2.2.3.3. [ ] : Deny all write access to the `schedules` collection for unauthenticated users and for MVP. (Risk: 3/10) (Complexity: 2/10)
    4.2.2.4.  [ ] : Set up Firebase Emulator Suite for local testing of security rules. (Risk: 3/10) (Complexity: 3/10)
        4.2.2.4.1. [ ] : Install/update Firebase CLI. Initialize Firestore emulator (`firebase init emulators` if not already done).
        4.2.2.4.2. [ ] : Configure `firebase.json` to use a specific port for the Firestore emulator (e.g., 8080) and ensure it loads the `firestore.rules` file.
        4.2.2.4.3. [ ] : Start the Firestore emulator before running tests (e.g., `firebase emulators:start --only firestore`).
    4.2.2.5.  [ ] : Write unit tests for security rules using `@firebase/rules-unit-testing` (v9 SDK version) with a test runner like Jest. (Risk: 5/10) (Complexity: 5/10 - Setting up test environment, writing comprehensive test cases for various scenarios)
        4.2.2.5.1. [ ] : Install necessary testing packages (e.g., `jest`, `@types/jest`, `@firebase/rules-unit-testing`).
        4.2.2.5.2. [ ] : Configure Jest (e.g., `jest.config.js`) for the testing environment.
        4.2.2.5.3. [ ] : Create test files (e.g., `firestore.rules.test.ts`).
        4.2.2.5.4. [ ] : In test setup (`beforeAll` or `beforeEach`):
            4.2.2.5.4.1. [ ] : Initialize `RulesTestEnvironment` using `initializeTestEnvironment`.
            4.2.2.5.4.2. [ ] : Clear Firestore data (`clearFirestoreData()`) before each test or test suite to ensure test isolation.
        4.2.2.5.5. [ ] : In test teardown (`afterAll` or `afterEach`):
            4.2.2.5.5.1. [ ] : Clean up the test environment (`testEnv.cleanup()`).
        4.2.2.5.6. [ ] : For the `trucks` collection, write tests to verify:
            4.2.2.5.6.1. [ ] : Unauthenticated users CAN `get` individual truck documents.
            4.2.2.5.6.2. [ ] : Unauthenticated users CAN `list` truck documents.
            4.2.2.5.6.3. [ ] : Unauthenticated users CANNOT `create`, `update`, or `delete` truck documents.
        4.2.2.5.7. [ ] : For the `schedules` collection, write tests to verify:
            4.2.2.5.7.1. [ ] : Unauthenticated users CAN `get` individual schedule documents.
            4.2.2.5.7.2. [ ] : Unauthenticated users CAN `list` schedule documents.
            4.2.2.5.7.3. [ ] : Unauthenticated users CANNOT `create`, `update`, or `delete` schedule documents.
        4.2.2.5.8. [ ] : Write a test to confirm the "default deny" rule by attempting to access an undefined collection path (should fail).
        4.2.2.5.9. [ ] : Use `testEnv.unauthenticatedContext()` to simulate unauthenticated requests.
        4.2.2.5.10. [ ] : Use `assertSucceeds()` and `assertFails()` for assertions on Firestore operations.
        4.2.2.5.11. [ ] : (Optional for MVP, but good practice) If any rules depend on existing data (not the case for current MVP rules), use `testEnv.withSecurityRulesDisabled()` to seed data before running the test.
    4.2.2.6.  [ ] : Utilize the Firebase Rules Playground in the Firebase console for quick, ad-hoc validation of rule logic against specific paths and operations during development. (Risk: 2/10) (Complexity: 2/10)
    4.2.2.7.  [ ] : Document the MVP security rules, the rationale behind them, and the testing strategy, including how to run the unit tests. (Risk: 2/10) (Complexity: 2/10)

### 5. Performance Optimization (Initial) (Risk: 3/10 - Standard optimizations for MVP) (Complexity: 3/10 - Mostly leveraging framework defaults and basic checks)
**5.2. Asset Optimization** (Risk: 3/10) (Complexity: 4/10 - SVG optimization can be involved, Next/Image has learning curve)
5.2.1. [ ] **Action:** Plan for basic image optimization. (Risk: 2/10) (Complexity: 2/10)
    5.2.1.1.  [ ] : Optimize truck SVG icons (e.g. using SVGO). (Risk: 3/10) (Complexity: 3/10)
    5.2.1.2.  [ ] : Plan to use Next.js `next/image` for future raster images. (Risk: 2/10) (Complexity: 2/10)

### 6. Accessibility Foundation (Risk: 4/10 - Requires conscious effort and testing) (Complexity: 4/10 - Applying WCAG guidelines and ARIA)
**6.2. Semantic HTML & ARIA** (Risk: 4/10) (Complexity: 4/10 - Applying semantic elements and ARIA attributes correctly)
6.2.1. [ ] **Action:** Use semantic HTML5 elements during component refactoring. (Risk: 3/10) (Complexity: 3/10)
6.2.2. [ ] **Action:** Plan for adding basic ARIA attributes. (Risk: 3/10) (Complexity: 3/10)

### 9. Development Workflow & QA Setup (MVP Foundational) (Risk: 4/10 - Setting up robust processes) (Complexity: 5/10 - Involves multiple tools, configurations, and process definitions)
9.0.  [ ] **Umbrella Task:** Establish and document development and QA workflows. (Risk: 4/10) (Complexity: 3/10 - Process definition and documentation)

**9.2. CI/CD Pipeline Setup (Vercel & GitHub Actions)** (Risk: 5/10 - Complex integration) (Complexity: 6/10 - Setting up automated workflows, scripts, and integrations)
9.2.1. [ ] **Action:** Configure pre-commit hooks. (Risk: 4/10) (Complexity: 4/10)
9.2.2. [ ] **Action:** Set up GitHub Actions workflow for CI (e.g., in `.github/workflows/ci.yml`). (Risk: 5/10) (Complexity: 6/10 - YAML scripting, debugging CI runs, ensuring reliability, caching, and secret management)
    9.2.2.1.  [ ] : Define workflow name and triggers (e.g., `on: [push, pull_request]` targeting `main` and `develop` branches). (Risk: 2/10) (Complexity: 2/10)
    9.2.2.2.  [ ] : Define a job (e.g., `build-and-test`) to run on a specified runner (e.g., `ubuntu-latest`). (Risk: 1/10) (Complexity: 1/10)
    9.2.2.3.  [ ] : Implement steps within the job:
        9.2.2.3.1. [ ] : Checkout code using `actions/checkout@v4` (or latest stable). (Risk: 1/10) (Complexity: 1/10)
        9.2.2.3.2. [ ] : Set up Bun using `oven-sh/setup-bun@v1` (or latest stable), specifying a Bun version consistent with the project. (Risk: 2/10) (Complexity: 2/10)
        9.2.2.3.3. [ ] : Implement Bun dependency caching using `actions/cache@v4`.
            9.2.2.3.3.1. [ ] : Path: `~/.bun/install/cache` (for POSIX runners).
            9.2.2.3.3.2. [ ] : Key: e.g., `${{ runner.os }}-bun-${{ hashFiles('**/bun.lockb') }}`.
            9.2.2.3.3.3. [ ] : Restore-keys: e.g., `${{ runner.os }}-bun-`. (Risk: 3/10) (Complexity: 3/10)
        9.2.2.3.4. [ ] : Install dependencies using `bun install --frozen-lockfile`. Consider running this step conditionally based on cache hit for Bun dependencies. (Risk: 2/10) (Complexity: 2/10)
        9.2.2.3.5. [ ] : Implement Next.js build caching using `actions/cache@v4` for the `.next/cache` directory.
            9.2.2.3.5.1. [ ] : Path: `.next/cache`.
            9.2.2.3.5.2. [ ] : Key: e.g., `${{ runner.os }}-nextjs-${{ hashFiles('**/bun.lockb') }}-${{ hashFiles('**/*.[jt]s', '**/*.[jt]sx') }}`. (Risk: 3/10) (Complexity: 3/10 - Key needs to be robust)
        9.2.2.3.6. [ ] : Create/Verify project scripts in `package.json` for linting, testing, and building (e.g., `lint`, `test`, `build`). (Risk: 2/10) (Complexity: 2/10 - Promotes cleaner YAML)
        9.2.2.3.7. [ ] : Add step to run linters: `bun run lint`. (Risk: 2/10) (Complexity: 2/10)
        9.2.2.3.8. [ ] : Add step to run unit & integration tests: `bun run test`. (Risk: 3/10) (Complexity: 3/10)
            9.2.2.3.8.1. [ ] : Plan for test report generation/upload if needed (e.g., JUnit XML for GitHub Actions test summary).
        9.2.2.3.9. [ ] : Add step to build the application: `bun run build`. (Risk: 3/10) (Complexity: 3/10)
    9.2.2.4.  [ ] : Securely manage any necessary environment variables or secrets for the CI workflow using GitHub Actions secrets (e.g., for API keys needed during build, or for deployment steps if added later). (Risk: 3/10) (Complexity: 2/10)
    9.2.2.5.  [ ] : Test the CI workflow thoroughly by pushing to branches and creating PRs. Debug any issues with YAML syntax, runner environment, caching, or script execution. (Risk: 4/10) (Complexity: 3/10)

**9.3. Testing Strategy Implementation (Initial)** (Risk: 5/10 - Requires discipline and good test design, understanding mocking strategies for Next.js and state management) (Complexity: 7/10 - Writing effective tests, setting up testing environment, mocking Next.js features, handling Server/Client components, and managing async state in tests)
9.3.1. [ ] **Action:** Set up Jest and React Testing Library (RTL) for the Next.js project. (Risk: 4/10) (Complexity: 4/10 - Ensuring correct configuration for Next.js with App Router, TypeScript, and SWC/Babel)
    9.3.1.1.  [ ] : Install Jest, RTL, and related dependencies (e.g., `jest-environment-jsdom`, `@testing-library/jest-dom`, `@testing-library/react`, `@testing-library/user-event`, `ts-jest` or SWC equivalent for Jest).
    9.3.1.2.  [ ] : Configure Jest using `next/jest` preset to handle Next.js specifics (SWC/Babel compilation, environment setup). Create `jest.config.js` and `jest.setup.js` (for global mocks/imports like `@testing-library/jest-dom`).
    9.3.1.3.  [ ] : Ensure `testEnvironment` is set to `jsdom` for component tests.
9.3.2. [ ] **Action:** Write initial unit tests for critical utility functions and core components, considering Next.js specifics. (Risk: 5/10) (Complexity: 6/10 - Designing meaningful tests, effectively mocking Next.js features, and distinguishing testing strategies for Server vs. Client Components)
    9.3.2.1.  [ ] : Identify 2-3 critical utility functions (pure functions if possible) for unit testing with Jest. (Risk: 2/10) (Complexity: 2/10)
        9.3.2.1.1. [ ] : Write unit tests covering various inputs and edge cases for these utility functions.
    9.3.2.2.  [ ] : Identify 2-3 core Client Components for unit testing with RTL. (Risk: 3/10) (Complexity: 3/10)
        9.3.2.2.1. [ ] : Mock Next.js specific hooks/components used by these Client Components (e.g., `useRouter`, `usePathname`, `useSearchParams` from `next/navigation`; `<Link>`, `<Image>`). Create mocks in a `__mocks__` directory or use `jest.mock()`.
        9.3.2.2.2. [ ] : Write tests focusing on component rendering based on props, user interactions (using `userEvent`), and simple state changes.
    9.3.2.3.  [ ] : For Server Components identified for testing: (Risk: 4/10) (Complexity: 4/10 - Server Components run server-side, so direct RTL testing is limited)
        9.3.2.3.1. [ ] : Prioritize extracting complex logic into testable utility functions (tested separately).
        9.3.2.3.2. [ ] : If a Server Component primarily fetches data and passes it to Client Components, test the data fetching function separately and unit test the receiving Client Components with mock props.
        9.3.2.3.3. [ ] : (Advanced/Optional for MVP unit tests) Explore strategies for testing the rendered output of simple Server Components if necessary, potentially involving more complex Jest setups or focusing on E2E/integration tests for full behavior.
9.3.3. [ ] **Action:** Write initial integration tests for key component interactions and user flows, focusing on Next.js context. (Risk: 5/10) (Complexity: 7/10 - Setting up mocks for external services/state, handling asynchronous operations, and testing interactions across multiple components)
    9.3.3.1.  [ ] : Identify 1-2 key user flows for integration testing (e.g., applying a filter updates the displayed list of trucks; searching for a truck and viewing its details on the map). (Risk: 3/10) (Complexity: 3/10)
    9.3.3.2.  [ ] : For each identified flow:
        9.3.3.2.1. [ ] : Design test case(s) focusing on user behavior and expected outcomes across the involved components.
        9.3.3.2.2. [ ] : Set up the test environment:
            9.3.3.2.2.1. [ ] : Render the entry point component(s) for the flow.
            9.3.3.2.2.2. [ ] : Mock Next.js router/navigation as needed for the flow.
            9.3.3.2.2.3. [ ] : Provide a controlled initial state for the Zustand store relevant to the flow (e.g., using a helper to initialize the store for testing).
            9.3.3.2.2.4. [ ] : Mock any external API calls (e.g., Firebase interactions if not using emulators for this level of test, or third-party APIs) using `jest.fn().mockResolvedValue()` or `msw`.
        9.3.3.2.3. [ ] : Simulate user actions using `@testing-library/user-event` (e.g., typing in search, clicking filter buttons).
        9.3.3.2.4. [ ] : Write assertions to verify expected outcomes in the DOM (e.g., list updates, map markers change (if testable via DOM attributes/text), navigation occurs). Use RTL's async queries (`findBy*`, `waitFor`) for asynchronous updates.
        9.3.3.2.5. [ ] : Ensure proper cleanup (e.g., `jest.clearAllMocks()`, RTL's `cleanup`) after each test.
9.3.4. [ ] **Action:** Integrate basic accessibility checks (a11y) into the testing workflow. (Risk: 4/10) (Complexity: 4/10)
    9.3.4.1.  [ ] : Install `jest-axe`.
    9.3.4.2.  [ ] : Add `toHaveNoViolations` checks from `jest-axe` to component tests to catch basic accessibility issues.

## Phase 2: Post-Launch Enhancements (Iterative Development) - Future Tasks (Risk: 6/10 - Higher complexity features, external dependencies, AI) (Complexity: 7/10 - Introduces more advanced and potentially novel development areas)
P2.0. [ ] **Umbrella Task:** Coordinate and oversee Phase 2 development. (Risk: 6/10) (Complexity: 3/10 - Higher level coordination)

### 10. Enhanced Data Management & AI Integration (Risk: 7/10 - Scraping and AI are inherently complex and can be unreliable) (Complexity: 8/10 - Involves external data sources, AI/ML, and robust error handling)
10.0. [ ] **Umbrella Task:** Oversee data enhancement and AI integration efforts. (Risk: 7/10) (Complexity: 3/10 - Technical oversight)

**10.1. Automated Data Collection & Parsing** (Risk: 8/10 - Scraping fragile, LLM parsing experimental, ethical/legal compliance) (Complexity: 8/10 - Significant development for scraping, LLM interaction, robust error handling, and adherence to ethical guidelines)
10.1.1. [ ] **Action:** Implement Firebase Scheduled Functions for daily scraping of publicly available food truck data (schedules, locations). (Risk: 7/10) (Complexity: 7/10 - Requires robust, ethical scraping logic, scheduling, resilience against website changes, and anti-bot measures)
    10.1.1.1. [ ] : Identify 1-2 primary target data sources for initial scraping, prioritizing sources with clear public data and permissive `robots.txt`/ToS. (Risk: 5/10) (Complexity: 4/10 - Involves ethical assessment, technical feasibility, and legal review)
        10.1.1.1.1. [ ] : For each potential target source:
            10.1.1.1.1.1. [ ] : Check for an official API first; prefer API over scraping if available and suitable.
            10.1.1.1.1.2. [ ] : Thoroughly review `robots.txt` for disallowed paths and `Crawl-delay` directives. Document findings.
            10.1.1.1.1.3. [ ] : Review Terms of Service for clauses related to automated access or data reproduction. Document findings.
            10.1.1.1.1.4. [ ] : Assess website structure (HTML, JavaScript rendering) to determine scraping complexity and tool requirements (e.g., simple HTTP GET vs. headless browser).
            10.1.1.1.1.5. [ ] : Identify the specific data points to be scraped (e.g., truck name, schedule, location, cuisine) and their HTML selectors.
        10.1.1.1.2. [ ] : Document the selected source(s), rationale, `robots.txt` rules, relevant ToS sections, and a data extraction plan.
    10.1.1.2. [ ] : Develop scraping script for the first primary source within a Firebase Function, focusing on robustness, maintainability, and ethical practices. (Risk: 7/10) (Complexity: 7/10 - Core scraping logic, handling dynamic content, resilient selectors, error handling, and adherence to ethical guidelines)
        10.1.1.2.1. [ ] : Choose appropriate scraping library/method:
            10.1.1.2.1.1. [ ] : Prefer simple HTTP clients (e.g., `axios`, `node-fetch`) for static content if Firebase Functions environment supports them well.
            10.1.1.2.1.2. [ ] : If JavaScript rendering is essential, evaluate Puppeteer/Playwright. Consider if a standard Firebase Function environment is sufficient (e.g., memory, timeout, allowed outbound connections) or if a more capable environment (e.g., Cloud Run integrated with Functions) would be needed for headless browsers (likely overkill for initial MVP, aim for simpler targets first).
        10.1.1.2.2. [ ] : Implement logic to fetch HTML content.
        10.1.1.2.3. [ ] : Use robust HTML parsing (e.g., `cheerio` for server-side parsing if using HTTP client) and specific, yet adaptable, selectors (e.g., prefer data attributes, stable class names; avoid overly brittle selectors based on DOM order).
        10.1.1.2.4. [ ] : Implement strict adherence to `robots.txt` (parsed dynamically or pre-checked).
        10.1.1.2.5. [ ] : Implement rate limiting:
            10.1.1.2.5.1. [ ] : Respect `Crawl-delay` from `robots.txt`.
            10.1.1.2.5.2. [ ] : Add configurable delays between requests (e.g., 5-10 seconds, adjustable).
            10.1.1.2.5.3. [ ] : For Firebase Functions, ensure delays are managed within a single function invocation if multiple pages from one site are scraped, or across invocations if scraping is distributed (more complex).
        10.1.1.2.6. [ ] : Set a clear, descriptive User-Agent string (e.g., "SCFoodTruckFinderBot/1.0; +[project_url_for_bot_info]").
        10.1.1.2.7. [ ] : Only scrape necessary data fields. Avoid downloading unnecessary assets (images, CSS, JS) if not needed for parsing.
        10.1.1.2.8. [ ] : (Future consideration if blocking occurs) Plan for IP rotation strategy (e.g., proxy services compatible with Firebase Functions), but acknowledge this adds complexity and cost. Firebase Functions may have some inherent IP variability.
    10.1.1.3. [ ] : Implement comprehensive error handling, logging, and basic monitoring for the scraper function. (Risk: 6/10) (Complexity: 5/10 - Ensuring issues are caught, logged, and potentially alerted for manual review)
        10.1.1.3.1. [ ] : Implement `try-catch` blocks for network requests, HTML parsing, and data processing stages.
        10.1.1.3.2. [ ] : Handle common HTTP error codes gracefully (e.g., 403 Forbidden, 404 Not Found, 429 Too Many Requests, 5xx Server Errors). Log them and decide on retry strategy (e.g., exponential backoff for transient errors, stop for persistent errors).
        10.1.1.3.3. [ ] : Log key events, errors, and outcomes to Firebase Cloud Logging (e.g., number of items scraped, specific errors encountered).
        10.1.1.3.4. [ ] : Consider setting up alerts for critical failures (e.g., via Cloud Monitoring or a simple notification on error).
    10.1.1.4. [ ] : Configure Firebase Scheduled Function for the first scraper. (Risk: 4/10) (Complexity: 4/10 - Firebase console/CLI setup, IAM permissions, timeout settings)
        10.1.1.4.1. [ ] : Define the schedule (e.g., daily at a specific time) using cron syntax.
        10.1.1.4.2. [ ] : Configure function timeout, memory, and region. Ensure timeout is sufficient for scraping task but not excessively long to incur unnecessary costs.
        10.1.1.4.3. [ ] : Set appropriate IAM permissions for the function if it needs to access other Firebase/Google Cloud services.
        10.1.1.4.4. [ ] : Test the scheduled function thoroughly using the Firebase Emulator Suite and then by deploying and monitoring a few initial runs.
    10.1.1.5. [ ] : Plan for ongoing maintenance and monitoring of the scraper. (Risk: 5/10) (Complexity: 3/10 - Acknowledging scrapers break)
        10.1.1.5.1. [ ] : Document common failure points (e.g., selector changes, IP blocks) and basic troubleshooting steps.
        10.1.1.5.2. [ ] : Schedule periodic checks to ensure the scraper is still functioning correctly and data quality is maintained.
10.1.2. [ ] **Action:** Develop AI/LLM integration for parsing unstructured text (e.g., scraped social media posts, event descriptions) into structured JSON data (e.g., location, time, event type). (Risk: 8/10) (Complexity: 8/10 - Novel application of LLMs, requires careful prompt engineering, leveraging structured output features, iterative testing, robust validation, and cost/token optimization)
    10.1.2.1. [ ] : Select LLM provider and model (Primary: Google Gemini; Fallback: OpenAI `gpt-4o-mini`). Prioritize models with native "Structured Output" capabilities that accept a JSON schema. (Risk: 4/10) (Complexity: 3/10 - Research, account setup, API key management, model capability assessment)
    10.1.2.2. [ ] : Define the target JSON schema for extracted data (e.g., using JSON Schema format or Pydantic models if using OpenAI's structured output). This schema will be provided to the LLM. (Risk: 5/10) (Complexity: 4/10 - Clear, unambiguous schema is crucial)
        10.1.2.2.1. [ ] : Include descriptions for each field in the schema to guide the LLM.
        10.1.2.2.2. [ ] : Specify data types (string, number, boolean, array, object) and whether fields are required.
    10.1.2.3. [ ] : Design initial prompts for structured data extraction. (Risk: 6/10) (Complexity: 5/10 - Even with structured output, good prompting helps)
        10.1.2.3.1. [ ] : Clearly instruct the LLM to extract information according to the provided schema.
        10.1.2.3.2. [ ] : Provide 1-2 high-quality examples (few-shot) of input text and the corresponding desired JSON output (matching the schema) if initial tests show it improves reliability with the chosen model.
        10.1.2.3.3. [ ] : Consider pre-processing input text (e.g., cleaning, chunking if very long and context can be localized) to optimize token usage and focus the LLM.
    10.1.2.4. [ ] : Implement a Firebase Function (or other server-side logic) to call the chosen LLM API. (Risk: 5/10) (Complexity: 5/10 - API integration, request/response handling, error management)
        10.1.2.4.1. [ ] : Securely handle API keys (e.g., via Firebase Function configuration/secrets).
        10.1.2.4.2. [ ] : Construct the API request, including the prompt and the JSON schema for structured output (if supported by the model/API).
        10.1.2.4.3. [ ] : Implement logic to parse the LLM's JSON response.
        10.1.2.4.4. [ ] : Implement robust error handling for API calls (timeouts, rate limits, API errors, malformed non-JSON responses if structured output fails).
    10.1.2.5. [ ] : Implement output validation using a library like Zod (for TypeScript/JavaScript). (Risk: 5/10) (Complexity: 4/10 - Even with schema-constrained output, validate against business logic or stricter types)
        10.1.2.5.1. [ ] : Create Zod schemas that mirror or extend the JSON schema provided to the LLM, potentially adding more specific business rule validations (e.g., date formats, value ranges).
        10.1.2.5.2. [ ] : Validate the parsed JSON output from the LLM against these Zod schemas.
    10.1.2.6. [ ] : Conduct a pilot phase: Test LLM output with a representative sample set of diverse unstructured data. Refine prompts, JSON schema, and Zod validation iteratively. (Risk: 7/10) (Complexity: 7/10 - Iteration is key, systematic testing, analysis of failures)
        10.1.2.6.1. [ ] : Prepare a diverse test dataset (e.g., 20-50 examples) with known correct structured data.
        10.1.2.6.2. [ ] : Evaluate LLM outputs against known correct data and Zod validation results. Identify common error types (e.g., missed fields, incorrect formatting not caught by basic JSON schema, hallucinations if structured output is not perfectly enforced).
        10.1.2.6.3. [ ] : Iteratively refine prompts, JSON schema (for LLM), and Zod schemas based on observed errors. Document versions and performance.
    10.1.2.7. [ ] : Plan for cost and token optimization. (Risk: 4/10) (Complexity: 3/10)
        10.1.2.7.1. [ ] : Monitor token usage per call.
        10.1.2.7.2. [ ] : Experiment with smaller, capable models that support structured output.
        10.1.2.7.3. [ ] : Refine prompts to be as concise as possible while maintaining clarity.
10.1.3. [ ] **Action:** Implement linter feedback loop (validation and re-prompting cycle) for AI-parsed data to improve accuracy and reliability, especially if native structured output isn't perfect or for complex business rule validation. (Risk: 7/10) (Complexity: 7/10 - Designing and building a resilient data processing pipeline)
    10.1.3.1. [ ] : If Zod validation (from previous action) fails, capture detailed error messages. (Risk: 3/10) (Complexity: 3/10)
    10.1.3.2. [ ] : Design and implement a re-prompting strategy for validation errors, with a limited number of retries (e.g., 1-2). (Risk: 6/10) (Complexity: 6/10 - Crafting effective re-prompts, managing retry state and count, cost implications)
        10.1.3.2.1. [ ] : Construct a new prompt for the LLM that includes:
            10.1.3.2.1.1. [ ] : The original input text (or relevant parts).
            10.1.3.2.1.2. [ ] : The LLM's previous (incorrect) JSON output.
            10.1.3.2.1.3. [ ] : The specific validation errors (from Zod) explaining what was wrong with the previous output.
            10.1.3.2.1.4. [ ] : Clear instructions to correct the output based on these errors, referencing the desired JSON schema.
        10.1.3.2.2. [ ] : Implement a retry counter to prevent infinite loops and excessive costs.
        10.1.3.2.3. [ ] : If re-prompting also fails after max retries, log the failure and the problematic data, and flag for human review or a fallback mechanism.
    10.1.3.3. [ ] : Develop a "dead-letter" queue or robust logging mechanism for data that consistently fails validation even after re-prompting. (Risk: 3/10) (Complexity: 3/10 - Ensuring problematic data isn't lost and can be analyzed for future improvements)
    10.1.3.4. [ ] : Test the entire linter feedback loop with various scenarios: valid data, easily correctable errors, and data likely to fail consistently. (Risk: 5/10) (Complexity: 4/10)
10.1.4. [ ] **Action:** Refine and implement ethical scraping practices throughout the scraping process. (Risk: 5/10) (Complexity: 5/10 - Implementing and consistently applying responsible scraping techniques, including `robots.txt` compliance, rate limiting, User-Agent management, and respecting ToS)
    10.1.4.1. [ ] : Implement dynamic `robots.txt` checks before scraping any new domain or on a periodic basis for existing domains. (Risk: 4/10) (Complexity: 4/10 - Fetching, parsing `robots.txt`, and respecting `Disallow` rules and `Crawl-delay` directives)
        10.1.4.1.1. [ ] : Develop or use a library to parse `robots.txt` files.
        10.1.4.1.2. [ ] : Ensure the scraper adheres to the rules specified for its User-Agent or the default (`*`) agent.
    10.1.4.2. [ ] : Implement robust and configurable rate limiting within the scraping function(s). (Risk: 4/10) (Complexity: 4/10 - Ensuring polite scraping speeds, potentially adaptable)
        10.1.4.2.1. [ ] : Introduce configurable delays between HTTP requests (e.g., respecting `Crawl-delay` from `robots.txt` or a default polite delay).
        10.1.4.2.2. [ ] : For Firebase Functions, if scraping many pages from one site in one invocation, ensure delays are implemented within the function's execution. For distributed scraping, consider if more advanced cross-function rate limiting is needed (potentially overkill for daily scraping of a few sources).
    10.1.4.3. [ ] : Set a clear, descriptive User-Agent string for all scraping requests. (Risk: 2/10) (Complexity: 1/10 - Easy to implement, good practice)
        10.1.4.3.1. [ ] : User-Agent should identify the bot (e.g., "SCFoodTruckFinderBot/1.0; +http://yourproject.url/botinfo") and ideally provide a contact method.
    10.1.4.4. [ ] : Document a process for reviewing Terms of Service (ToS) of target websites before initiating scraping. (Risk: 3/10) (Complexity: 2/10 - Process definition, not technical implementation)
    10.1.4.5. [ ] : Ensure scraped data handling complies with privacy best practices (e.g., avoid storing unnecessary PII, anonymize/aggregate if possible). (Risk: 4/10) (Complexity: 3/10)
    10.1.4.6. [ ] : Prefer official APIs over scraping if they become available and meet data needs. (Risk: 2/10) (Complexity: 1/10 - Policy/Strategy)

**10.2. Firestore Data Model Expansion** (Risk: 4/10) (Complexity: 5/10 - Designing and implementing schema changes, considering data migration)
10.2.1. [ ] **Action:** Expand Firestore schema. (Risk: 4/10) (Complexity: 5/10)
    10.2.1.1. [ ] : Design schema for `user_profiles` (e.g., display name, photo URL, notification preferences). (Risk: 3/10) (Complexity: 3/10)
    10.2.1.2. [ ] : Design schema for `favorites` (e.g., a collection per user storing IDs of favorited trucks). (Risk: 3/10) (Complexity: 3/10)
    10.2.1.3. [ ] : Design schema for `notifications` (if storing notification history or user-specific notification data). (Risk: 3/10) (Complexity: 3/10)
10.2.2. [ ] **Action:** Refine Firebase Security Rules for new data models (`user_profiles`, `favorites`, `notifications`), ensuring a "default deny" posture and applying the principle of least privilege. (Risk: 6/10) (Complexity: 6/10 - Writing granular, secure, and testable rules for user-specific data, considering data validation and access patterns)
    10.2.2.1. [ ] : Write security rules for `user_profiles` collection (`/users/{userId}`). (Risk: 5/10) (Complexity: 5/10)
        10.2.2.1.1. [ ] : Ensure users can only create their own profile document (e.g., `allow create: if request.auth.uid == userId && isCreating();`).
        10.2.2.1.2. [ ] : Ensure users can only read their own profile (`allow get: if request.auth.uid == userId;`).
            10.2.2.1.2.1. [ ] : For public fields (e.g., `displayName`, `photoURL` on a *separate* public profile collection if needed, or carefully structured main profile), define separate `allow get` rules if other users can read them. (e.g. `match /public_profiles/{userId} { allow get: if true; }`)
        10.2.2.1.3. [ ] : Ensure users can only update their own profile (`allow update: if request.auth.uid == userId && isUpdating();`).
        10.2.2.1.4. [ ] : Prohibit deletion of profiles by users, or restrict it carefully (`allow delete: if false;` or `if isAdmin();`).
        10.2.2.1.5. [ ] : Implement `.validate` rules for `user_profiles` data using `request.resource.data`.
            10.2.2.1.5.1. [ ] : Validate `displayName`: `isString(request.resource.data.displayName, 3, 50)`.
            10.2.2.1.5.2. [ ] : Validate `photoURL`: `request.resource.data.photoURL == null || (isString(request.resource.data.photoURL) && request.resource.data.photoURL.matches('https^?://.*'))`.
            10.2.2.1.5.3. [ ] : Validate `createdAt`: `request.resource.data.createdAt == request.time` (on create).
            10.2.2.1.5.4. [ ] : Validate `updatedAt`: `request.resource.data.updatedAt == request.time` (on update).
            10.2.2.1.5.5. [ ] : Validate `notificationPreferences` (Map): `request.resource.data.notificationPreferences is map` and specific keys within it are boolean (e.g., `request.resource.data.notificationPreferences.newTruckAlerts is bool`).
            10.2.2.1.5.6. [ ] : Disallow unspecified fields on update: `request.resource.data.keys().hasOnly(['displayName', 'photoURL', 'notificationPreferences', 'updatedAt', 'createdAt'])` (ensure `createdAt` cannot be changed on update using `isUnchanged('createdAt')`).
    10.2.2.2. [ ] : Write security rules for `favorites` data (e.g., `/users/{userId}/favorites/{truckId}`). (Risk: 5/10) (Complexity: 5/10)
        10.2.2.2.1. [ ] : Ensure users can only create/delete favorite entries under their own `userId` path (`allow create, delete: if request.auth.uid == userId;`).
        10.2.2.2.2. [ ] : Ensure users can only read their own list of favorites (`allow list, get: if request.auth.uid == userId;`).
        10.2.2.2.3. [ ] : Prohibit updates to favorite entries (they are typically create/delete operations) (`allow update: if false;`).
        10.2.2.2.4. [ ] : Implement `.validate` rules for favorite entries.
            10.2.2.2.4.1. [ ] : If storing `truckId` in the document data: `request.resource.data.truckId == truckId` (validating against wildcard) and `exists(/databases/$(database)/documents/trucks/$(request.resource.data.truckId))`.
            10.2.2.2.4.2. [ ] : If storing `createdAt`: `request.resource.data.createdAt == request.time`.
            10.2.2.2.4.3. [ ] : Ensure only expected fields are present (e.g., `request.resource.data.keys().hasOnly(['truckId', 'createdAt'])`). If it's a marker document with no fields, validate `request.resource.data.size() == 0`.
    10.2.2.3. [ ] : Write security rules for `notifications` data, if applicable (e.g. `/users/{userId}/notifications/{notificationId}`). (Risk: 5/10) (Complexity: 5/10)
        10.2.2.3.1. [ ] : Determine who can create notifications (likely server-side via Admin SDK, so client-side create might be `allow create: if false;` or `if isAdmin();`).
        10.2.2.3.2. [ ] : Ensure users can only read their own notifications (`allow list, get: if request.auth.uid == userId;`).
        10.2.2.3.3. [ ] : Allow users to update (e.g., mark as read) or delete their own notifications (`allow update, delete: if request.auth.uid == userId;`).
        10.2.2.3.4. [ ] : Implement `.validate` rules for notification documents.
            10.2.2.3.4.1. [ ] : Validate `title`: `isString(request.resource.data.title, 1, 100)`.
            10.2.2.3.4.2. [ ] : Validate `body`: `isString(request.resource.data.body, 1, 250)`.
            10.2.2.3.4.3. [ ] : Validate `readStatus`: `request.resource.data.readStatus is bool`.
            10.2.2.3.4.4. [ ] : Validate `createdAt`: `request.resource.data.createdAt == request.time` (on create).
            10.2.2.3.4.5. [ ] : Validate `type`: `isString(request.resource.data.type) && request.resource.data.type.matches('^(alert|info|promo)$')` (example enum).
            10.2.2.3.4.6. [ ] : On update, ensure only `readStatus` can be changed by the user: `request.resource.data.keys().hasOnly(['readStatus'])` or check `isUnchanged()` for other fields.
    10.2.2.4. [ ] : Define and use helper functions in rules for common conditions. (Risk: 3/10) (Complexity: 3/10)
        10.2.2.4.1. [ ] : `function isAuthenticated() { return request.auth != null; }`
        10.2.2.4.2. [ ] : `function isOwner(docUserId) { return isAuthenticated() && request.auth.uid == docUserId; }`
        10.2.2.4.3. [ ] : `function isCreating() { return resource == null || !exists(request.path); }` (More accurately for create: `request.resource.id == <wildcard> && !exists(/databases/$(database)/documents/collection/$(request.resource.id))`) or simply `!exists(pathAfterWildcard)`
        10.2.2.4.4. [ ] : `function isUpdating() { return exists(request.path); }` (More accurately for update: `exists(/databases/$(database)/documents/collection/$(request.resource.id))`)
        10.2.2.4.5. [ ] : `function incomingData() { return request.resource.data; }`
        10.2.2.4.6. [ ] : `function existingData() { return resource.data; }`
        10.2.2.4.7. [ ] : `function isString(value, minLength, maxLength) { return value is string && value.size() >= minLength && value.size() <= maxLength; }`
        10.2.2.4.8. [ ] : `function isBoolean(value) { return value is bool; }`
        10.2.2.4.9. [ ] : `function isTimestamp(value) { return value is timestamp; }`
        10.2.2.4.10. [ ] : `function isOneOf(value, allowedValuesList) { return value in allowedValuesList; }`
        10.2.2.4.11. [ ] : `function hasOnlyAllowedFields(data, allowedKeysList) { return data.keys().hasOnly(allowedKeysList); }`
        10.2.2.4.12. [ ] : `function isUnchanged(fieldName) { return incomingData()[fieldName] == existingData()[fieldName]; }`
        10.2.2.4.13. [ ] : `function isAdmin() { return isAuthenticated() && get(/databases/$(database)/documents/admins/$(request.auth.uid)).data.isAdmin == true; }` (Example, requires `admins` collection)
    10.2.2.5. [ ] : Thoroughly test all new security rules using the Firebase Emulator Suite and `@firebase/rules-unit-testing`. (Risk: 4/10) (Complexity: 4/10)
        10.2.2.5.1. [ ] : For `user_profiles`:
            10.2.2.5.1.1. [ ] : Test authenticated user creates own profile (valid data succeeds, invalid data fails validation).
            10.2.2.5.1.2. [ ] : Test authenticated user attempts to create profile for another UID (fails).
            10.2.2.5.1.3. [ ] : Test authenticated user reads own profile (succeeds).
            10.2.2.5.1.4. [ ] : Test authenticated user attempts to read another's profile (fails, unless specific public fields are allowed).
            10.2.2.5.1.5. [ ] : Test authenticated user updates own profile (valid data succeeds, invalid data fails, changing disallowed fields like `createdAt` fails).
            10.2.2.5.1.6. [ ] : Test authenticated user attempts to update another's profile (fails).
            10.2.2.5.1.7. [ ] : Test authenticated user attempts to delete own profile (fails as per rule).
        10.2.2.5.2. [ ] : For `favorites`:
            10.2.2.5.2.1. [ ] : Test authenticated user creates/deletes own favorite (succeeds if `truckId` is valid and exists, fails otherwise).
            10.2.2.5.2.2. [ ] : Test authenticated user attempts to create/delete favorite for another UID (fails).
            10.2.2.5.2.3. [ ] : Test authenticated user reads own list of favorites (succeeds).
            10.2.2.5.2.4. [ ] : Test authenticated user attempts to read another's favorites (fails).
            10.2.2.5.2.5. [ ] : Test authenticated user attempts to update a favorite entry (fails).
        10.2.2.5.3. [ ] : For `notifications`:
            10.2.2.5.3.1. [ ] : Test authenticated user attempts to create a notification (fails, as per rule).
            10.2.2.5.3.2. [ ] : (Requires admin context in tests) Test server/admin creates a notification (succeeds with valid data).
            10.2.2.5.3.3. [ ] : Test authenticated user reads own notifications (succeeds).
            10.2.2.5.3.4. [ ] : Test authenticated user attempts to read another's notifications (fails).
            10.2.2.5.3.5. [ ] : Test authenticated user updates own notification (e.g., `readStatus`) (succeeds for allowed fields, fails for disallowed field changes).
            10.2.2.5.3.6. [ ] : Test authenticated user attempts to update another's notification (fails).
            10.2.2.5.3.7. [ ] : Test authenticated user deletes own notification (succeeds).
        10.2.2.5.4. [ ] : Utilize Rules Playground for quick ad-hoc validation during rule development.
    10.2.2.6. [ ] : Document the rationale and structure of the refined security rules, including helper functions and data validation logic. (Risk: 2/10) (Complexity: 2/10)

### 11. User Accounts & Personalization (Risk: 6/10 - Auth and user data management are sensitive) (Complexity: 6/10 - Building secure auth flows, UI, and managing user-specific data)
**11.1. User Authentication & Profile** (Risk: 5/10) (Complexity: 5/10 - Integrating auth provider and building related UI)
11.1.1. [ ] **Action:** Implement full user registration, sign-in, and account management using Firebase Authentication, prioritizing social/federated login and email link where appropriate. (Risk: 5/10) (Complexity: 6/10 - Handling different auth providers, UI flows, state management, and security best practices)
    11.1.1.1. [ ] : Evaluate using FirebaseUI for a pre-built, best-practice auth UI, or decide on custom UI implementation. (Risk: 2/10) (Complexity: 2/10 - Decision point affecting subsequent UI tasks)
        11.1.1.1.1. [ ] : Analyze FirebaseUI capabilities (supported providers, UI customization options, ease of integration).
        11.1.1.1.2. [ ] : Compare with project's specific UX/UI requirements, need for deep customization, and long-term maintenance.
        11.1.1.1.3. [ ] : Document decision and rationale. If custom, proceed with detailed UI component design.
    11.1.1.2. [ ] : Design and create custom UI components (if not using FirebaseUI) for Login, Sign-up, Password Reset, and Email Link flows. (Risk: 4/10) (Complexity: 4/10)
        11.1.1.2.1. [ ] : Ensure components handle loading states, display clear error messages (from Firebase or custom validation), and provide success feedback.
        11.1.1.2.2. [ ] : Implement client-side input validation (e.g., email format, password strength policies) before calling Firebase methods.
    11.1.1.3. [ ] : Implement Firebase Auth SDK for Google Social Login as a primary sign-in option. (Risk: 4/10) (Complexity: 4/10 - Configuration in Firebase console, SDK integration, callback handling)
        11.1.1.3.1. [ ] : Enable Google Sign-In provider in Firebase console and configure OAuth consent screen in Google Cloud Console.
        11.1.1.3.2. [ ] : Implement `signInWithPopup(provider)` or `signInWithRedirect(provider)` using `GoogleAuthProvider`.
        11.1.1.3.3. [ ] : Handle the `UserCredential` object on successful sign-in.
        11.1.1.3.4. [ ] : Implement error handling, especially for `auth/account-exists-with-different-credential` (trigger account linking flow) and `auth/popup-closed-by-user`.
    11.1.1.4. [ ] : Implement Firebase Auth SDK for Email Link sign-in/sign-up (passwordless). (Risk: 5/10) (Complexity: 5/10 - Requires careful state handling across email and app)
        11.1.1.4.1. [ ] : Define `ActionCodeSettings` with `url` (deep link back to the app), `handleCodeInApp: true`, and Android/iOS specific settings if applicable.
        11.1.1.4.2. [ ] : Implement UI for user to enter their email.
        11.1.1.4.3. [ ] : Call `sendSignInLinkToEmail(auth, email, actionCodeSettings)`. Store email locally (e.g., `localStorage`) to use when link is clicked.
        11.1.1.4.4. [ ] : On app load or when the deep link is handled:
            11.1.1.4.4.1. [ ] : Check if `isSignInWithEmailLink(auth, window.location.href)`.
            11.1.1.4.4.2. [ ] : Retrieve stored email. If not available, prompt user for it.
            11.1.1.4.4.3. [ ] : Call `signInWithEmailLink(auth, email, window.location.href)` to complete sign-in.
            11.1.1.4.4.4. [ ] : Clear stored email from `localStorage`.
        11.1.1.4.5. [ ] : Handle errors (e.g., invalid link, expired link, email mismatch).
    11.1.1.5. [ ] : Implement Firebase Auth SDK for Email/Password sign-up and sign-in as a secondary option. (Risk: 4/10) (Complexity: 4/10)
        11.1.1.5.1. [ ] : For sign-up, use `createUserWithEmailAndPassword(auth, email, password)`. Handle errors like `auth/email-already-in-use`, `auth/weak-password`.
        11.1.1.5.2. [ ] : For sign-in, use `signInWithEmailAndPassword(auth, email, password)`. Handle errors like `auth/user-not-found`, `auth/wrong-password`, `auth/too-many-requests`.
        11.1.1.5.3. [ ] : Implement email verification flow for new email/password sign-ups:
            11.1.1.5.3.1. [ ] : After successful `createUserWithEmailAndPassword`, call `sendEmailVerification(auth.currentUser, actionCodeSettings?)`.
            11.1.1.5.3.2. [ ] : Optionally, configure `ActionCodeSettings` for the verification email to redirect user back to app.
            11.1.1.5.3.3. [ ] : UI to inform user to check email and verify. Periodically check `auth.currentUser.emailVerified` or require re-login.
    11.1.1.6. [ ] : Implement "Forgot Password" (password reset) functionality for email/password accounts. (Risk: 4/10) (Complexity: 4/10 - Requesting reset, handling email link, UI for new password input)
        11.1.1.6.1. [ ] : UI for user to enter their registered email.
        11.1.1.6.2. [ ] : Call `sendPasswordResetEmail(auth, email, actionCodeSettings?)`.
        11.1.1.6.3. [ ] : Optionally, configure `ActionCodeSettings` for the reset email.
        11.1.1.6.4. [ ] : Configure password reset email template in Firebase console (branding, wording).
        11.1.1.6.5. [ ] : (Handled by Firebase) Firebase provides a page for user to enter new password.
    11.1.1.7. [ ] : Implement global authentication state management. (Risk: 4/10) (Complexity: 5/10)
        11.1.1.7.1. [ ] : Use `onAuthStateChanged(auth, (user) => { ... })` listener at the root of the application.
        11.1.1.7.2. [ ] : Update a global store (e.g., React Context, Zustand) with the `user` object (if signed in) or `null` (if signed out).
        11.1.1.7.3. [ ] : Components subscribe to this store to reactively update UI based on auth status (e.g., show profile vs. login button).
        11.1.1.7.4. [ ] : Ensure listener is set up early in app lifecycle and unsubscribed on cleanup.
    11.1.1.8. [ ] : Implement sign-out functionality. (Risk: 2/10) (Complexity: 2/10)
        11.1.1.8.1. [ ] : Call `signOut(auth)`.
        11.1.1.8.2. [ ] : Ensure global auth state is updated and UI reflects signed-out status. Clear any sensitive local user data.
    11.1.1.9. [ ] : Implement Account Linking for users signing in with multiple providers. (Risk: 4/10) (Complexity: 5/10)
        11.1.1.9.1. [ ] : Handle `auth/account-exists-with-different-credential` error:
            11.1.1.9.1.1. [ ] : Prompt user that an account with their email already exists via another provider.
            11.1.1.9.1.2. [ ] : Fetch sign-in methods for the email: `fetchSignInMethodsForEmail(auth, email)`.
            11.1.1.9.1.3. [ ] : Guide user to sign in with one of the existing methods.
            11.1.1.9.1.4. [ ] : After successful sign-in with existing method, link the new credential (from `error.customData.credential`) to the current user: `linkWithCredential(auth.currentUser, newCredential)`.
    11.1.1.10. [ ] : Consider implementing anonymous authentication on initial app load, with a path to upgrade to a permanent account. (Risk: 3/10) (Complexity: 3/10 - Optional enhancement)
        11.1.1.10.1. [ ] : Call `signInAnonymously(auth)` on app start if no user is signed in.
        11.1.1.10.2. [ ] : Provide UI/flow for anonymous user to upgrade by linking a permanent auth provider (e.g., Google, Email/Password) using `linkWithCredential(auth.currentUser, permanentCredential)`.
    11.1.1.11. [ ] : Review and implement security best practices for authentication.
        11.1.1.11.1. [ ] : Plan for re-authentication (`reauthenticateWithCredential`) before sensitive operations (e.g., changing email, deleting account).
        11.1.1.11.2. [ ] : Ensure Firebase API keys in client-side config are appropriately restricted (Firebase console settings).
        11.1.1.11.3. [ ] : Follow guidelines for handling `ActionCodeSettings` URLs securely.
    11.1.1.12. [ ] : Plan for future Multi-Factor Authentication (MFA) if handling highly sensitive data (e.g., via Identity Platform). (Risk: 2/10) (Complexity: 1/10 - Planning, not immediate implementation)
11.1.2. [ ] : Ensure secure handling of API keys (Firebase config is generally safe client-side, but review any custom backend interactions) and implement robust, user-friendly error handling for all auth operations. (Risk: 3/10) (Complexity: 3/10)
11.1.3. [ ] **Action:** Develop UI for user profile screen (account management). (Risk: 4/10) (Complexity: 5/10 - Form handling, data updates to Firestore, auth operations)
    11.1.3.1. [ ] : Design UI for profile screen allowing users to view and manage their account details. (Risk: 3/10) (Complexity: 3/10)
    11.1.3.2. [ ] : Implement display of user profile info (from `auth.currentUser` and Firestore `user_profiles` document). (Risk: 3/10) (Complexity: 3/10)
    11.1.3.3. [ ] : Implement functionality to update profile information (e.g., display name, photo URL - updates both Firebase Auth profile and Firestore `user_profiles`).
        11.1.3.3.1. [ ] : `updateProfile(auth.currentUser, { displayName, photoURL })`.
        11.1.3.3.2. [ ] : Update corresponding fields in Firestore `user_profiles` document.
    11.1.3.4. [ ] : Implement functionality to update email address.
        11.1.3.4.1. [ ] : May require re-authentication.
        11.1.3.4.2. [ ] : Call `verifyBeforeUpdateEmail(auth.currentUser, newEmail, actionCodeSettings?)` (preferred) or `updateEmail(auth.currentUser, newEmail)`.
        11.1.3.4.3. [ ] : Handle email verification for the new email.
    11.1.3.5. [ ] : Implement functionality to change password (for email/password accounts).
        11.1.3.5.1. [ ] : Requires re-authentication.
        11.1.3.5.2. [ ] : Call `updatePassword(auth.currentUser, newPassword)`.
    11.1.3.6. [ ] : Implement functionality to link/unlink auth providers.
    11.1.3.7. [ ] : Implement functionality to delete account (`deleteUser(auth.currentUser)`).
        11.1.3.7.1. [ ] : Requires re-authentication.
        11.1.3.7.2. [ ] : Clearly communicate consequences. Handle associated data deletion (e.g., Firestore profile, user-generated content) via Cloud Functions triggered by user deletion.

**11.2. Favorites & Notifications** (Risk: 6/10) (Complexity: 7/10 - Backend logic for notifications, multi-channel delivery)
11.2.1. [ ] **Action:** Implement "Favorite" truck functionality, allowing users to mark/unmark trucks as favorites and view their list of favorites. (Risk: 5/10) (Complexity: 6/10 - Managing user-truck relationships in Firestore, UI state, and integration with global state)
    11.2.1.1. [ ] : Design Firestore data model for storing user favorites. (Risk: 4/10) (Complexity: 4/10 - Consider scalability and query patterns)
        11.2.1.1.1. [ ] : Confirm use of subcollection under each user: `/users/{userId}/favorites/{truckId}`. The document ID will be the `truckId`.
        11.2.1.1.2. [ ] : The document itself can be empty or store a `favoritedAt: serverTimestamp()` field for sorting or tracking when it was favorited. For MVP, an empty document is sufficient.
    11.2.1.2. [ ] : Implement UI elements for favoriting (e.g., a "favorite" icon/button on `FoodTruckCardComponent` and truck detail pages). (Risk: 3/10) (Complexity: 4/10)
        11.2.1.2.1. [ ] : Button state (e.g., filled/empty heart icon) must clearly reflect if a truck is currently favorited by the logged-in user, based on real-time data from the Zustand store.
    11.2.1.3. [ ] : Implement client-side logic (e.g., in a Zustand store action) for optimistic UI updates and Firestore interaction. (Risk: 4/10) (Complexity: 4/10 - Async operations, error handling, updating global state)
        11.2.1.3.1. [ ] : Define Zustand store slice for favorites (e.g., `favoritedTruckIds: string[]`).
        11.2.1.3.2. [ ] : On favorite button click:
            11.2.1.3.2.1. [ ] : Immediately update `favoritedTruckIds` in Zustand store (add/remove `truckId`) to provide instant UI feedback (optimistic update).
            11.2.1.3.2.2. [ ] : Asynchronously call a Firestore operation:
                *   If adding: `setDoc(doc(db, 'users', userId, 'favorites', truckId), { favoritedAt: serverTimestamp() })` (or empty object).
                *   If removing: `deleteDoc(doc(db, 'users', userId, 'favorites', truckId))`.
            11.2.1.3.2.3. [ ] : Handle successful Firestore operation (no specific action needed if optimistic update was correct).
            11.2.1.3.2.4. [ ] : Handle Firestore operation error: Revert the Zustand state to its previous value and display a user-friendly error message (e.g., "Could not update favorite status. Please try again.").
        11.2.1.3.3. [ ] : Ensure these operations are protected by Firebase Security Rules (users can only modify their own favorites - covered in 10.2).
        11.2.1.3.4. [ ] : On initial app load for an authenticated user, fetch their current list of favorite `truckId`s from `/users/{userId}/favorites` and populate the Zustand store.
    11.2.1.4. [ ] : Create a dedicated "Favorites" screen/section where users can view a list of their favorited trucks. (Risk: 3/10) (Complexity: 3/10)
        11.2.1.4.1. [ ] : Fetch the list of `truckId`s from the user's `/users/{userId}/favorites` subcollection (or use the list from Zustand store if already populated and kept in sync).
        11.2.1.4.2. [ ] : For each `truckId` in the favorites list, fetch the full truck details from the main `/trucks/{truckId}` collection to display (e.g., in `FoodTruckCardComponent` instances).
        11.2.1.4.3. [ ] : (Post-MVP consideration) For performance with many favorites, consider pagination or denormalizing key truck info into the favorite document (adds complexity).
    11.2.1.5. [ ] : Ensure robust error handling and clear user feedback for all favorite-related operations (e.g., loading states, success messages if appropriate, detailed error messages for failures). (Risk: 3/10) (Complexity: 2/10)
11.2.2. [ ] **Action:** Develop notification system (Email via Nodemailer/Firebase Functions, Push via FCM initially), allowing users to receive timely updates. (Risk: 7/10) (Complexity: 8/10 - Integrating multiple notification services, managing user subscriptions, designing triggers, and handling delivery at scale)
    11.2.2.1. [ ] : Plan initial notification triggers, content, and underlying data structures. (Risk: 4/10) (Complexity: 4/10)
        11.2.2.1.1. [ ] : Define specific Firestore events or data changes that trigger notifications (e.g., new document in `user_generated_alerts` collection, status update in `truck_schedules` for a favorited truck).
        11.2.2.1.2. [ ] : Example Triggers: "Favorited truck X is opening nearby soon", "New truck Y matching your cuisine preference added", "Weekly digest of events".
        11.2.2.1.3. [ ] : Define basic text/HTML content templates for each notification type (for both email and push), including placeholders for dynamic data (e.g., truck name, event time).
    11.2.2.2. [ ] : Set up Firebase Cloud Messaging (FCM) for web push notifications. (Risk: 5/10) (Complexity: 5/10 - Client and server setup)
        11.2.2.2.1. [ ] : Client-Side FCM Setup (Web - JavaScript/TypeScript):
            11.2.2.2.1.1. [ ] : Initialize Firebase SDK for messaging in the client app.
            11.2.2.2.1.2. [ ] : Obtain VAPID key from Firebase Console (Project settings > Cloud Messaging > Web configuration).
            11.2.2.2.1.3. [ ] : Create `public/firebase-messaging-sw.js` service worker to handle background notifications. Initialize Firebase app in SW: `firebase.initializeApp({...})`. Handle `onBackgroundMessage`.
            11.2.2.2.1.4. [ ] : Implement logic to request notification permission: `Notification.requestPermission()`.
            11.2.2.2.1.5. [ ] : If permission granted, get FCM registration token: `getToken(getMessaging(), { vapidKey: "YOUR_VAPID_KEY" })`.
            11.2.2.2.1.6. [ ] : Store the user's FCM token(s) in their Firestore `user_profiles/{userId}` document (e.g., in a `fcmTokens` map or array, handling multiple devices/browsers per user). Update on new token generation.
            11.2.2.2.1.7. [ ] : Implement `onTokenRefresh` listener to update stored tokens when they change.
            11.2.2.2.1.8. [ ] : Implement `onMessage` listener in the foreground app to handle incoming messages when app is active (e.g., display an in-app notification UI).
        11.2.2.2.2. [ ] : Server-Side FCM Logic (Firebase Functions using Admin SDK):
            11.2.2.2.2.1. [ ] : Initialize Firebase Admin SDK in your Functions.
            11.2.2.2.2.2. [ ] : Implement Firebase Function(s) triggered by relevant events (e.g., Firestore `onWrite` to `pending_notifications`, `onCall` for direct user actions, `onSchedule` for digests).
            11.2.2.2.2.3. [ ] : Inside the Function, retrieve target user's FCM token(s) from their Firestore profile.
            11.2.2.2.2.4. [ ] : Construct the message payload (e.g., `notification: { title, body, icon }, data: { click_action_url }`).
            11.2.2.2.2.5. [ ] : Send message using `admin.messaging().sendToDevice(tokens, payload)` or `admin.messaging().send(message)`.
            11.2.2.2.2.6. [ ] : Implement error handling for send operations (e.g., `messaging/invalid-registration-token`, `messaging/registration-token-not-registered`). Remove invalid/stale tokens from user's Firestore profile.
            11.2.2.2.2.7. [ ] : Adhere to FCM best practices (e.g., retries with exponential backoff for transient errors).
    11.2.2.3. [ ] : Integrate Nodemailer with Firebase Functions for sending email notifications. (Risk: 6/10) (Complexity: 5/10 - Configuration, email templating, function triggers)
        11.2.2.3.1. [ ] : Securely configure Nodemailer transporter.
            11.2.2.3.1.1. [ ] : Choose an email service (e.g., SendGrid, Mailgun, AWS SES). Obtain API key or SMTP credentials.
            11.2.2.3.1.2. [ ] : Store credentials securely using Firebase Function environment configuration (e.g., `functions.config().sendgrid.apikey`). Do NOT hardcode credentials.
            11.2.2.3.1.3. [ ] : Initialize Nodemailer transporter with service details and credentials.
        11.2.2.3.2. [ ] : Create basic HTML email templates (e.g., using string literals with interpolation, or a simple templating library like Handlebars if complexity grows).
        11.2.2.3.3. [ ] : Develop Firebase Function(s) (e.g., triggered by Firestore, callable, or scheduled) to:
            11.2.2.3.3.1. [ ] : Fetch necessary data (target user's email from `user_profiles`, notification-specific content).
            11.2.2.3.3.2. [ ] : Compose email options (to, from, subject, html body using templates).
            11.2.2.3.3.3. [ ] : Send email using `transporter.sendMail(mailOptions)`.
        11.2.2.3.4. [ ] : Implement unsubscribe links/mechanisms in emails (e.g., a link to a web page that calls a Firebase Function to update the user's notification preferences in Firestore).
        11.2.2.3.5. [ ] : Implement error handling for email sending (e.g., invalid email address format, email service API errors). Log errors.
    11.2.2.4. [ ] : Implement robust error handling, logging, and monitoring for both FCM and email notification sending processes. (Risk: 4/10) (Complexity: 3/10)
    11.2.2.5. [ ] : Test notification delivery thoroughly for various scenarios (different triggers, user preference states, foreground/background app for push) and platforms. (Risk: 5/10) (Complexity: 4/10)
11.2.3. [ ] **Action:** Implement Notifications Settings screen. (Risk: 4/10) (Complexity: 5/10 - Managing multiple toggles and saving preferences)
    11.2.3.1. [ ] : Design UI for notification toggles (e.g., "New Truck Alerts," "Favorite Truck Updates," "Weekly Digest," "Promotional Emails").
    11.2.3.2. [ ] : Store user notification preferences in their Firestore `user_profiles/{userId}` document (e.g., `notificationPreferences: { newTruckAlerts: true, weeklyDigest: false, promoEmails: true }`).
    11.2.3.3. [ ] : Ensure notification-sending Firebase Functions check these preferences in the user's profile before attempting to send a notification of a particular type.
    11.2.3.4. [ ] : Implement client-side logic to update these preferences in Firestore when toggles are changed.

### 12. Advanced Discovery & Interaction (Risk: 5/10) (Complexity: 6/10 - More sophisticated UI and search logic)
**12.1. Search & Filter Enhancements** (Risk: 5/10) (Complexity: 6/10 - Building more powerful search/filter capabilities)
12.1.1. [ ] **Action:** Implement advanced search functionality in header, considering both client-side filtering for immediate results and planning for robust backend full-text search. (Risk: 6/10) (Complexity: 7/10 - Balancing immediate UX with scalable search architecture)
    12.1.1.1. [ ] : Implement client-side filtering for currently displayed/loaded data (e.g., truck names, cuisine types in the `TruckListComponent` or map view). (Risk: 4/10) (Complexity: 4/10 - Debouncing input, filtering logic, updating UI)
        12.1.1.1.1. [ ] : Use JavaScript array methods (e.g., `filter()`, `String.prototype.toLowerCase()`, `String.prototype.includes()`) for efficient, case-insensitive partial matching on relevant fields.
        12.1.1.1.2. [ ] : Implement debouncing for the search input using a custom hook or a library (e.g., `lodash.debounce`) to delay filtering execution until user stops typing (e.g., 300-500ms delay). Manage search term in React state.
    12.1.1.2. [ ] : Research and select a third-party full-text search service (e.g., Algolia, Typesense) for integration with Firestore. (Risk: 5/10) (Complexity: 4/10 - Evaluating features, pricing, ease of integration, Firebase extensions)
        12.1.1.2.1. [ ] : Compare Algolia and Typesense based on project needs (typo tolerance, faceting, geo-search, cost, maintenance, developer experience).
        12.1.1.2.2. [ ] : Prioritize evaluating the official Algolia Firebase Extension ("Search with Algolia") for simplified data synchronization. If Typesense or manual Algolia sync is chosen, plan for custom Cloud Functions.
    12.1.1.3. [ ] : Plan data synchronization from Firestore to the chosen search service. (Risk: 5/10) (Complexity: 5/10 - Designing Cloud Functions, defining data to index, handling updates/deletes, security of API keys)
        12.1.1.3.1. [ ] : Define which Firestore collections/fields (e.g., from `trucks` collection: `name`, `cuisine`, `description`) need to be indexed for search.
        12.1.1.3.2. [ ] : If using Algolia Extension: Configure the extension with collection path, fields to index, and Algolia credentials.
        12.1.1.3.3. [ ] : If custom Cloud Functions are needed (e.g., for Typesense or manual Algolia sync):
            12.1.1.3.3.1. [ ] : Create an `onCreate` Cloud Function triggered by new documents in the target Firestore collection to add data to the search index.
            12.1.1.3.3.2. [ ] : Create an `onUpdate` Cloud Function to update corresponding records in the search index.
            12.1.1.3.3.3. [ ] : Create an `onDelete` Cloud Function to remove records from the search index.
            12.1.1.3.3.4. [ ] : Securely store search service Admin API keys in Firebase Function environment configuration.
    12.1.1.4. [ ] : (Potentially Post-MVP or if time allows for MVP) Implement basic integration with the chosen search service using its client SDK and UI components. (Risk: 6/10) (Complexity: 6/10 - SDK setup, UI component integration, search result display, API key management)
        12.1.1.4.1. [ ] : Install client SDKs (e.g., `algoliasearch` or `typesense-js`, and `react-instantsearch-hooks-web` or `react-instantsearch` for Typesense).
        12.1.1.4.2. [ ] : Initialize the search client in the Next.js app using the Search-Only API Key and App ID provided by the search service. (Search-Only API keys are generally safe to expose client-side).
        12.1.1.4.3. [ ] : Integrate `react-instantsearch` components:
            12.1.1.4.3.1. [ ] : Wrap search UI with `<InstantSearch searchClient={searchClient} indexName="your_index_name">`.
            12.1.1.4.3.2. [ ] : Use `<SearchBox />` for the search input.
            12.1.1.4.3.3. [ ] : Use `<Hits hitComponent={CustomHit} />` to display results, where `CustomHit` is a React component that renders each search result (e.g., using a modified `FoodTruckCardComponent`).
        12.1.1.4.4. [ ] : Style search components to match application theme.
    12.1.1.5. [ ] : Document the chosen search strategy, including client-side limitations, backend synchronization method (extension or custom functions), and client-side integration details. (Risk: 2/10) (Complexity: 2/10)
12.1.2. [ ] **Action:** Develop modal overlay for comprehensive filter options. (Risk: 4/10) (Complexity: 5/10)
    12.1.2.1. [ ] : Design UI for filter modal. (Risk: 3/10) (Complexity: 3/10)
    12.1.2.2. [ ] : Implement state for modal filters (extend Zustand). (Risk: 3/10) (Complexity: 3/10)
    12.1.2.3. [ ] : Apply combined modal filters to map/list. (Risk: 4/10) (Complexity: 3/10)

**12.2. External Integrations** (Risk: 6/10) (Complexity: 6/10 - Dealing with external APIs, data transformation, error handling, and adherence to third-party terms)
12.2.1. [ ] **Action:** Integrate Google Places API or Yelp Fusion API to fetch and display truck ratings/reviews. (Risk: 6/10) (Complexity: 7/10 - Involves API key management, backend function development, data caching, error handling, and adherence to API terms & display requirements)
    12.2.1.1. [ ] : Research and decide between Google Places API and Yelp Fusion API. (Risk: 4/10) (Complexity: 3/10)
        12.2.1.1.1. [ ] : Focus research on data availability/quality for food trucks (ratings, review counts, review snippets, photos).
        12.2.1.1.2. [ ] : Compare pricing models, API rate limits, and specific terms of service regarding data caching and display requirements (attribution).
        12.2.1.1.3. [ ] : Check developer community feedback regarding ease of integration and reliability for food truck related queries.
    12.2.1.2. [ ] : Securely set up API keys for the chosen service. (Risk: 3/10) (Complexity: 2/10)
        12.2.1.2.1. [ ] : Store API keys in Firebase Function environment configuration (e.g., `functions.config().service.api_key` for 1st gen, or use Secret Manager for 2nd gen Functions).
        12.2.1.2.2. [ ] : Restrict API key usage in the respective cloud console if possible (e.g., by HTTP referrer for client-side keys if any, or by IP for server-side keys if supported by provider, though less common for server-to-server).
    12.2.1.3. [ ] : Develop a Firebase Callable Function to act as a proxy for API calls. (Risk: 5/10) (Complexity: 5/10)
        12.2.1.3.1. [ ] : Define clear input parameters for the callable function (e.g., `{ truckId: string, truckName: string, truckAddressHint?: string, truckLat?: number, truckLng?: number }`).
        12.2.1.3.2. [ ] : Implement logic within the function to construct the appropriate external API request (e.g., search by name and location hint).
        12.2.1.3.3. [ ] : Call the external API using an HTTP client (e.g., `axios` or `node-fetch`) with the securely stored API key in headers/params as required by the provider.
        12.2.1.3.4. [ ] : Transform the raw API response: Parse the JSON, extract only necessary fields (e.g., `averageRating`, `reviewCount`, `photoReferences`, a few top review snippets), and map them to a consistent internal data structure.
        12.2.1.3.5. [ ] : Implement robust error handling:
            12.2.1.3.5.1. [ ] : Catch errors from the external API call (network issues, 4xx/5xx status codes).
            12.2.1.3.5.2. [ ] : Handle cases where no matching business is found.
            12.2.1.3.5.3. [ ] : Return meaningful error objects to the client (e.g., `{ error: true, code: 'not-found', message: '...' }`).
    12.2.1.4. [ ] : Implement a caching strategy for API responses within the Callable Function using Firestore. (Risk: 4/10) (Complexity: 4/10)
        12.2.1.4.1. [ ] : Create a Firestore collection (e.g., `external_api_cache`).
        12.2.1.4.2. [ ] : Use a unique identifier for cache documents (e.g., `google_places_${truckId}` or a hash of query parameters).
        12.2.1.4.3. [ ] : Store the transformed API response and a `cachedAt: serverTimestamp()` field in the cache document.
        12.2.1.4.4. [ ] : Define a TTL (e.g., 24 hours). Before making an external API call, query Firestore for a document with the unique ID where `cachedAt` is within the TTL.
        12.2.1.4.5. [ ] : If a fresh cache entry exists, return its data. Otherwise, call the external API, store the (transformed) result in the cache with the current timestamp, then return the result.
    12.2.1.5. [ ] : Implement UI on the Truck Detail Screen (and potentially `FoodTruckCardComponent`) to display fetched ratings/reviews. (Risk: 4/10) (Complexity: 4/10)
        12.2.1.5.1. [ ] : Client-side calls the Firebase Callable Function with necessary parameters.
        12.2.1.5.2. [ ] : Display loading indicators while data is being fetched.
        12.2.1.5.3. [ ] : Display fetched data (e.g., star rating, review count). If review snippets are available, display them.
        12.2.1.5.4. [ ] : Handle and display error states gracefully (e.g., "Ratings unavailable," "Could not load reviews").
        12.2.1.5.5. [ ] : Ensure compliance with API provider's display requirements, especially attribution (e.g., "Powered by Google" logo, "Reviews from Yelp" text/logo).
    12.2.1.6. [ ] : Thoroughly test the integration: successful calls, cached responses, API errors, no results found, and UI states. (Risk: 4/10) (Complexity: 3/10)
    12.2.1.7. [ ] : Document the API integration: chosen API, key management, callable function logic, caching strategy, data transformation, and attribution requirements. (Risk: 2/10) (Complexity: 2/10)

### 14. SEO & AI Search Optimization (Advanced) (Risk: 6/10) (Complexity: 7/10 - Requires understanding of SEO best practices, Next.js rendering, and structured data)
14.0. [ ] **Umbrella Task:** Oversee SEO and AI Search Optimization efforts. (Risk: 6/10) (Complexity: 3/10 - Coordination and strategy)

**14.1. SSR/SSG Implementation** (Risk: 5/10) (Complexity: 6/10 - Correctly implementing Next.js data fetching and rendering strategies for optimal SEO and performance)
14.1.1. [ ] **Action:** Strategically leverage Next.js rendering capabilities (SSG, SSR, ISR using App Router features) for optimal SEO and performance. (Risk: 5/10) (Complexity: 6/10)
    14.1.1.1. [ ] : Identify and categorize pages for appropriate rendering strategies. (Risk: 4/10) (Complexity: 3/10)
        14.1.1.1.1. [ ] : Purely static content pages (e.g., "About Us", "Privacy Policy", `/legal/[slug]`):
            14.1.1.1.1.1. [ ] : Target for SSG. Use default `fetch` (which is `cache: 'force-cache'`) in Server Components.
            14.1.1.1.1.2. [ ] : If segments are dynamic but known at build time (e.g., `/legal/[slug]`), use `generateStaticParams` to provide the `slug` values.
        14.1.1.1.2. [ ] : Truck detail pages (`/trucks/{truckId}`):
            14.1.1.1.2.1. [ ] : Target for ISR. Use `fetch` with `next: { revalidate: <seconds> }` (e.g., `3600` for 1 hour) in the Server Component for the page.
            14.1.1.1.2.2. [ ] : Optionally, use `generateStaticParams` to pre-render a subset of popular truck pages at build time. Set `export const dynamicParams = true;` to allow on-demand server-rendering for new/un-generated `truckId`s, which will then be cached for ISR.
        14.1.1.1.3. [ ] : Main list/map view page (`/` or `/trucks`):
            14.1.1.1.3.1. [ ] : For initial SEO & perceived performance: Consider ISR for a shell or a small, representative subset of data (e.g., first 10 trucks) using `fetch` with `next: { revalidate: <seconds> }`.
            14.1.1.1.3.2. [ ] : Alternatively, if data must be absolutely live on first load (less common for a list view), use SSR with `fetch` and `cache: 'no-store'`.
            14.1.1.1.3.3. [ ] : Subsequent filtering, searching, and loading more items will be handled client-side (CSR).
    14.1.1.2. [ ] : Implement data fetching in Server Components using `async/await` with `fetch`. (Risk: 5/10) (Complexity: 5/10)
        14.1.1.2.1. [ ] : For SSG (default): `const data = await fetch('api/static-content');` (implicitly `cache: 'force-cache'`).
        14.1.1.2.2. [ ] : For ISR: `const data = await fetch('api/trucks/${id}', { next: { revalidate: 3600 } });`
        14.1.1.2.3. [ ] : For SSR: `const data = await fetch('api/live-data', { cache: 'no-store' });`
    14.1.1.3. [ ] : Implement `generateStaticParams` for dynamic routes intended for SSG or build-time ISR.
        14.1.1.3.1. [ ] : Example for `/trucks/[id]`: `export async function generateStaticParams() { const trucks = await fetch('.../trucks-ids').then(res => res.json()); return trucks.map(truck => ({ id: truck.id })); }`
    14.1.1.4. [ ] : Implement dynamic metadata generation using `generateMetadata` for relevant pages. (Risk: 4/10) (Complexity: 4/10)
        14.1.1.4.1. [ ] : `export async function generateMetadata({ params }) { const item = await fetch('api/item/${params.id}').then(res => res.json()); return { title: item.title, description: item.description }; }`
        14.1.1.4.2. [ ] : Ensure `fetch` calls within `generateMetadata` use appropriate caching (default `force-cache` is usually fine as metadata is often tied to build-time or revalidated data).
    14.1.1.5. [ ] : Test and verify rendering strategies. (Risk: 3/10) (Complexity: 2/10)
        14.1.1.5.1. [ ] : Inspect Next.js build output logs to confirm which pages are statically generated (SSG/ISR at build).
        14.1.1.5.2. [ ] : Use browser developer tools (Network tab, response headers like `Cache-Control`, `X-Vercel-Cache`) to check caching behavior for ISR/SSR pages.
        14.1.1.5.3. [ ] : View page source to confirm pre-rendered content for SEO.
    14.1.1.6. [ ] : Monitor build times and server load (for SSR/ISR) as content grows, and adjust revalidation periods or `generateStaticParams` strategies if needed. (Risk: 2/10) (Complexity: 2/10)

**14.2. Structured Data & Metadata** (Risk: 6/10) (Complexity: 6/10 - Implementing JSON-LD and dynamic meta tags correctly for various page types)
14.2.1. [ ] **Action:** Implement Schema.org structured data markup (JSON-LD) for relevant page types to enhance SEO. (Risk: 6/10) (Complexity: 7/10 - Requires careful schema selection, dynamic data population, and validation)
    14.2.1.1. [ ] : Research and define appropriate Schema.org types and properties. (Risk: 4/10) (Complexity: 4/10)
        14.2.1.1.1. [ ] : For Individual Food Truck pages: Use `FoodEstablishment` (or `Restaurant`). Key properties: `name`, `address` (with `streetAddress`, `addressLocality`, `addressRegion`, `postalCode`), `geo` (`GeoCoordinates` with `latitude`, `longitude`), `telephone`, `image` (URL), `servesCuisine`, `menu` (URL to menu if available), `openingHoursSpecification` (`OpeningHoursSpecification` objects).
        14.2.1.1.2. [ ] : For Food Truck schedule/events: Use `Event`. Key properties: `name` (e.g., "Truck X at Location Y"), `startDate`, `endDate` (ISO 8601 format), `location` (as a `Place` schema with `name`, `address`, `geo`), `organizer` (linking to the `FoodEstablishment`). Can be embedded within `FoodEstablishment` or as separate linked entities.
        14.2.1.1.3. [ ] : For Main list pages (e.g., search results, category pages): Use `ItemList`. Key properties: `itemListElement` (an array of `ListItem` objects, where each `ListItem` references a `FoodEstablishment` by URL or contains a summarized `FoodEstablishment` object).
    14.2.1.2. [ ] : Develop a reusable React Server Component (e.g., `JsonLdScript.tsx`) to generate and inject JSON-LD `<script>` tags. (Risk: 4/10) (Complexity: 4/10)
        14.2.1.2.1. [ ] : Component should accept a schema object (or array of objects) as a prop.
        14.2.1.2.2. [ ] : Use `schema-dts` for TypeScript typings of schema objects to ensure correctness.
        14.2.1.2.3. [ ] : Render `<script type="application/ld+json" dangerouslySetInnerHTML={{ __html: JSON.stringify(schema) }} />`. Place this component within the `<body>` of relevant `page.tsx` files.
    14.2.1.3. [ ] : Implement dynamic JSON-LD generation in Server Components for page types:
        14.2.1.3.1. [ ] : Individual Food Truck pages (`/trucks/[id]/page.tsx`): Fetch truck data, construct the `FoodEstablishment` schema object (including `Event` schemas for its schedule if applicable), and pass to `JsonLdScript` component. (Risk: 5/10) (Complexity: 5/10)
        14.2.1.3.2. [ ] : Main list/map view page: Fetch list of trucks, construct an `ItemList` schema where each `itemListElement` contains a summarized `FoodEstablishment` (name, URL, image, short description), and pass to `JsonLdScript`. (Risk: 4/10) (Complexity: 4/10)
    14.2.1.4. [ ] : Validate all JSON-LD implementations. (Risk: 3/10) (Complexity: 2/10 - Crucial testing step)
        14.2.1.4.1. [ ] : Use Google's Rich Results Test for pages intended for rich snippets.
        14.2.1.4.2. [ ] : Use the Schema Markup Validator (validator.schema.org) for general schema validation.
14.2.2. [ ] : Monitor structured data in Google Search Console for errors or warnings after deployment. (Risk: 2/10) (Complexity: 1/10)
14.2.3. [ ] **Action:** Optimize dynamic titles, meta descriptions, and Open Graph (OG) tags using Next.js `generateMetadata` function. (Risk: 4/10) (Complexity: 4/10)
    14.2.3.1. [ ] : For dynamic pages (e.g., truck detail pages), implement `export async function generateMetadata({ params })` in `page.tsx`.
    14.2.3.2. [ ] : Fetch necessary data within `generateMetadata` (e.g., truck name, description, main image) using `fetch` with appropriate caching.
    14.2.3.3. [ ] : Return an object with `title`, `description`, and `openGraph` properties (including `og:title`, `og:description`, `og:image`, `og:type`, `og:url`).
    14.2.3.4. [ ] : Ensure unique and descriptive metadata for each page type.
    14.2.3.5. [ ] : Test metadata using browser developer tools and social media sharing debuggers (e.g., Facebook Sharing Debugger, Twitter Card Validator).

### 15. Mobile App Store Deployment (Android) (Risk: 7/10) (Complexity: 7/10 - Dealing with native tooling, build systems, and app store requirements)
15.0. [ ] **Umbrella Task:** Oversee Capacitor integration and Android deployment. (Risk: 7/10) (Complexity: 3/10 - Coordination)

**15.1. Capacitor Integration** (Risk: 6/10) (Complexity: 6/10 - Setting up Capacitor, configuring for Next.js static export, and ensuring compatibility)
15.1.1. [ ] **Action:** Integrate Ionic Capacitor into the Next.js project to enable native mobile app builds. (Risk: 6/10) (Complexity: 7/10 - Involves Next.js build configuration, Capacitor setup, platform-specific considerations, and potential troubleshooting of static export issues with dynamic routes or image optimization)
    15.1.1.1. [ ] : Install Capacitor CLI & core dependencies (`@capacitor/core`, `@capacitor/cli`). (Risk: 2/10) (Complexity: 2/10)
    15.1.1.2. [ ] : Initialize Capacitor in the Next.js project (`npx cap init`). (Risk: 2/10) (Complexity: 2/10)
    15.1.1.3. [ ] : Add target native platforms (e.g., Android: `npx cap add android`). (Risk: 2/10) (Complexity: 2/10)
    15.1.1.4. [ ] : Configure Next.js for static export. (Risk: 5/10) (Complexity: 4/10 - Ensuring `next.config.js` is set up for `output: 'export'`, and addressing implications for dynamic routes and image optimization)
        15.1.1.4.1. [ ] : In `next.config.js` (or `.mjs`), set `output: 'export'`.
        15.1.1.4.2. [ ] : For dynamic routes (e.g., `/trucks/[id]`), implement `generateStaticParams` to ensure these pages are pre-rendered during export.
        15.1.1.4.3. [ ] : Review and potentially adjust `next/image` usage if default optimization causes issues with static export (e.g., consider disabling optimization or using a custom loader for exported app).
    15.1.1.5. [ ] : Configure Capacitor's `webDir` to point to the Next.js static export output directory. (Risk: 4/10) (Complexity: 3/10)
        15.1.1.5.1. [ ] : In `capacitor.config.ts` (or `.json`), set `webDir: 'out'` (or the configured Next.js export directory).
    15.1.1.6. [ ] : Build the Next.js app for static export (`npm run build` or `bun run build`, assuming export is part of the build script). (Risk: 3/10) (Complexity: 2/10)
    15.1.1.7. [ ] : Sync Capacitor with the exported web assets (`npx cap sync`). (Risk: 2/10) (Complexity: 2/10)
    15.1.1.8. [ ] : Test the basic functionality of the exported Next.js app within a Capacitor WebView on the target platform (e.g., Android emulator/device). (Risk: 4/10) (Complexity: 4/10 - Initial check for routing, asset loading, basic interactivity).
    15.1.1.9. [ ] : (Optional, for development workflow) Configure Capacitor `server.url` for live reload with Next.js dev server if needed, separate from production build. (Risk: 3/10) (Complexity: 3/10)
15.1.2. [ ] **Action:** Configure Capacitor for Android specific settings (e.g., permissions, plugins). (Risk: 4/10) (Complexity: 4/10)
    15.1.2.1. [ ] : Review and add necessary Android permissions in `AndroidManifest.xml` (e.g., Internet, location if used by native features).
    15.1.2.2. [ ] : Install and configure any required Capacitor plugins (e.g., Geolocation, Camera) and sync (`npx cap sync`).

**15.2. Android App Build & Customization** (Risk: 7/10) (Complexity: 7/10 - Working with Android Studio, Gradle, manifests, and resolving native build issues)
15.2.1. [ ] **Action:** Use Android Studio to open, build, and customize the native Android project generated by Capacitor. (Risk: 6/10) (Complexity: 6/10 - Involves native tooling, Gradle configuration, and potential troubleshooting)
    15.2.1.1. [ ] : Open the `android` folder in Android Studio (`npx cap open android`). (Risk: 1/10) (Complexity: 1/10)
    15.2.1.2. [ ] : Perform initial Gradle sync. Troubleshoot common sync issues: (Risk: 5/10) (Complexity: 4/10)
        15.2.1.2.1. [ ] : Ensure `JAVA_HOME` environment variable is correctly set to Android Studio's embedded JDK path (e.g., `/Applications/Android Studio.app/Contents/jbr/Contents/Home` on Mac).
        15.2.1.2.2. [ ] : Use Android Studio's "File > Sync Project with Gradle Files" option.
        15.2.1.2.3. [ ] : If issues persist, try "Build > Clean Project" then "Build > Rebuild Project".
        15.2.1.2.4. [ ] : Check `android/gradle/wrapper/gradle-wrapper.properties` for `distributionUrl` and ensure Gradle version is compatible with Android Gradle Plugin version in `android/build.gradle`.
        15.2.1.2.5. [ ] : Check for and resolve missing dependencies or SDK component issues via Android Studio's SDK Manager.
    15.2.1.3. [ ] : Configure app icons and splash screens using Android Studio's Asset Studio ("File > New > Image Asset") or by replacing placeholder files in `res` directories. (Risk: 4/10) (Complexity: 3/10)
    15.2.1.4. [ ] : Review and adjust `android/app/src/main/AndroidManifest.xml` for app name (`android:label`), package ID (`package`), permissions, and other necessary configurations. (Risk: 4/10) (Complexity: 4/10)
    15.2.1.5. [ ] : Review and adjust module-level `android/app/build.gradle` for: (Risk: 5/10) (Complexity: 4/10)
        15.2.1.5.1. [ ] : `minSdkVersion` (align with Capacitor's support, e.g., API 22 for Capacitor 5).
        15.2.1.5.2. [ ] : `compileSdkVersion` and `targetSdkVersion` (use latest stable API level, e.g., 33 or 34, as per Google Play requirements).
        15.2.1.5.3. [ ] : `versionCode` (integer, must be incremented for each Play Store release).
        15.2.1.5.4. [ ] : `versionName` (user-facing string, e.g., "1.0.0").
        15.2.1.5.5. [ ] : Any custom dependencies or configurations.
    15.2.1.6. [ ] : Test debug builds on an emulator and physical device. (Risk: 3/10) (Complexity: 3/10)
15.2.2. [ ] **Action:** Prepare a signed Android App Bundle (AAB) for Google Play Store submission. (Risk: 5/10) (Complexity: 6/10 - Keystore management, signing configuration, and AAB generation are critical and error-prone)
    15.2.2.1. [ ] : Generate a new upload keystore using Android Studio's "Build > Generate Signed Bundle / APK..." wizard. (Risk: 4/10) (Complexity: 4/10)
        15.2.2.1.1. [ ] : Select "Android App Bundle" and click Next.
        15.2.2.1.2. [ ] : Click "Create new..." under Key store path.
        15.2.2.1.3. [ ] : Choose a secure path for the keystore file (e.g., outside the project directory, in a backed-up location).
        15.2.2.1.4. [ ] : Create strong passwords for the keystore and the key alias. Document these securely (e.g., in a password manager).
        15.2.2.1.5. [ ] : Fill in the certificate information (alias, validity period - e.g., 25 years).
        15.2.2.1.6. [ ] : Securely back up the generated `.jks` (or `.keystore`) file. Losing this key means you cannot update your app.
    15.2.2.2. [ ] : Configure the module-level `android/app/build.gradle` with signing configurations for the "release" build type. (Risk: 4/10) (Complexity: 4/10)
        15.2.2.2.1. [ ] : Add keystore details to `gradle.properties` (ensure this file is in `.gitignore`):
            ```properties
            MYAPP_UPLOAD_STORE_FILE=your_keystore_filename.jks
            MYAPP_UPLOAD_KEY_ALIAS=your_key_alias
            MYAPP_UPLOAD_STORE_PASSWORD=your_keystore_password
            MYAPP_UPLOAD_KEY_PASSWORD=your_key_password
            ```
        15.2.2.2.2. [ ] : In `android/app/build.gradle`, reference these properties in the `signingConfigs.release` block:
            ```gradle
            signingConfigs {
                release {
                    storeFile file(project.property('MYAPP_UPLOAD_STORE_FILE'))
                    storePassword project.property('MYAPP_UPLOAD_STORE_PASSWORD')
                    keyAlias project.property('MYAPP_UPLOAD_KEY_ALIAS')
                    keyPassword project.property('MYAPP_UPLOAD_KEY_PASSWORD')
                }
            }
            buildTypes {
                release {
                    signingConfig signingConfigs.release
                    // ... other release configurations
                }
            }
            ```
    15.2.2.3. [ ] : Generate the signed AAB using Android Studio ("Build > Generate Signed Bundle / APK...", select "Android App Bundle", choose "release" build variant, and select the configured keystore). (Risk: 3/10) (Complexity: 3/10)
    15.2.2.4. [ ] : Test the generated AAB locally using `bundletool` or by uploading to Google Play Console's Internal Testing track before a production release. (Risk: 4/10) (Complexity: 3/10)

**15.3. Live Updates Strategy (Over-the-Air - OTA)** (Risk: 6/10) (Complexity: 7/10 - Implementing or integrating a live update mechanism for web assets, ensuring security and reliability)
15.3.1. [ ] **Action:** Investigate and select a live update (OTA) solution for pushing web asset updates to deployed Capacitor apps. (Risk: 6/10) (Complexity: 4/10 - Researching options, comparing features, pricing, and ease of integration)
    15.3.1.1. [ ] : Prioritize Capgo (`@capgo/capacitor-updater`) as the primary candidate due to its Capacitor-native focus, open-source server option, features (encryption, channels, CI/CD integration), and positive community feedback as an alternative to Ionic Appflow.
    15.3.1.2. [ ] : Review Capgo's pricing (free tier, paid plans), security features (end-to-end encryption), and detailed integration steps from their documentation.
    15.3.1.3. [ ] : Briefly note Ionic Appflow as a more enterprise-focused, potentially more expensive option, and that its live update feature is a core offering.
    15.3.1.4. [ ] : Note self-hosting a CodePush fork as a high-complexity alternative if managed services are not viable.
    15.3.1.5. [ ] : Document the chosen solution (likely Capgo) and rationale.
15.3.2. [ ] **Action:** Plan the integration of Capgo for OTA updates. (Risk: 5/10) (Complexity: 5/10 - SDK integration, build pipeline adjustments, update strategy)
    15.3.2.1. [ ] : SDK Integration: Plan to install `@capgo/capacitor-updater` (plugin) and `@capgo/cli` (for uploading bundles).
    15.3.2.2. [ ] : Update Check: Configure the app to check for updates on app start using Capgo SDK methods (e.g., `CapacitorUpdater.notifyAppReady()` and automatic checks, or manual `CapacitorUpdater.download()` flow).
    15.3.2.3. [ ] : Build Process for Update Bundles:
        15.3.2.3.1. [ ] : The update bundle will consist of the static web assets generated by `next build` (typically in the `out` directory).
        15.3.2.3.2. [ ] : Use `@capgo/cli bundle build` (if needed) and `@capgo/cli bundle upload --channel <channel_name>` to upload the `out` directory to the Capgo service.
        15.3.2.3.3. [ ] : Plan to integrate this upload step into the CI/CD pipeline (e.g., GitHub Actions) to run after a successful web asset build for specific branches/tags.
    15.3.2.4. [ ] : Update Strategy:
        15.3.2.4.1. [ ] : Default to silent updates (Capgo's default behavior) for minor fixes and content changes.
        15.3.2.4.2. [ ] : Investigate Capgo's options for user-prompted updates if more control is desired for significant feature changes (may involve custom UI around Capgo's download/install methods).
        15.3.2.4.3. [ ] : Research Capgo's capabilities for mandatory updates for critical fixes.
    15.3.2.5. [ ] : Channel Management:
        15.3.2.5.1. [ ] : Plan to use Capgo channels (e.g., `production`, `beta`, `develop`).
        15.3.2.5.2. [ ] : Map CI/CD environments or Git branches to these channels (e.g., `main` branch deploys to `production` channel, `develop` branch to `develop` channel).
    15.3.2.6. [ ] : Document the Capgo setup process, API key management (if any for CLI), CI/CD integration steps, and the update deployment workflow.
    15.3.2.7. [ ] : Remember that OTA updates only apply to web assets. Native code changes (plugins, custom native code) still require a new app store submission.
15.3.3. [ ] **Action:** (Potentially Post-MVP or if time allows) Implement basic integration of Capgo. (Risk: 6/10) (Complexity: 6/10 - Involves SDK setup, manual test cycle, error handling considerations, and initial CI planning)
    15.3.3.1. [ ] **: Initial Setup & Configuration (Capgo)** (Risk: 5/10) (Complexity: 4/10)
        15.3.3.1.1. [ ] : Install `@capgo/capacitor-updater` (plugin) and `@capgo/cli` (as a dev dependency). Ensure versions are compatible with the project's Capacitor core and other relevant plugins. (Risk: 3/10) (Complexity: 2/10)
        15.3.3.1.2. [ ] : Set up a Capgo account and create an app instance on their cloud service. Securely store any API keys/tokens provided by Capgo (e.g., for CLI usage) using the project's agreed-upon secret management strategy (e.g., GitHub secrets for CI, local environment variables for manual CLI use). (Risk: 3/10) (Complexity: 2/10)
        15.3.3.1.3. [ ] : Configure the Capgo plugin within the Capacitor application according to the official Capgo documentation (this might involve settings in `capacitor.config.ts`, or modifications to native app delegate files like `MainActivity.java` or `AppDelegate.swift`). (Risk: 4/10) (Complexity: 3/10)
        15.3.3.1.4. [ ] : Implement the initial update check logic within the app (e.g., on app startup using `CapacitorUpdater.notifyAppReady()` for automatic checks, or by implementing a manual check flow triggered by user action or specific app events). (Risk: 4/10) (Complexity: 4/10)
        15.3.3.1.5. [ ] : Research and consider implementing configurable delays for update checks, as suggested by Capgo best practices, to optimize app startup performance. Document decision. (Risk: 3/10) (Complexity: 2/10)
    15.3.3.2. [ ] **: First OTA Update Test Cycle (Manual)** (Risk: 5/10) (Complexity: 5/10 - End-to-end manual test of the update mechanism)
        15.3.3.2.1. [ ] : Prepare an initial web asset bundle for Capgo:
            15.3.3.2.1.1. [ ] : Confirm the Next.js application is correctly configured for static export (`output: 'export'` in `next.config.js`).
            15.3.3.2.1.2. [ ] : Ensure all dynamic routes intended for static export have `generateStaticParams` implemented.
            15.3.3.2.1.3. [ ] : Execute the Next.js build command (e.g., `bun run build`) to generate the static assets in the `out` directory.
        15.3.3.2.2. [ ] : Perform an initial manual upload of the generated `out` directory to a designated Capgo `develop` (or other non-production) channel using the `@capgo/cli bundle upload --channel develop` command. (Risk: 3/10) (Complexity: 2/10)
        15.3.3.2.3. [ ] : Build and run the Capacitor application (with the Capgo plugin integrated) on an Android emulator or physical device. This build should contain the web assets *before* the update.
        15.3.3.2.4. [ ] : Make a small, easily verifiable visual change to a web asset within the Next.js project (e.g., update text content in a prominent component, change a color).
        15.3.3.2.5. [ ] : Re-build the Next.js static assets to include this change.
        15.3.3.2.6. [ ] : Upload this new `out` directory as an update to the same Capgo `develop` channel using the CLI.
        15.3.3.2.7. [ ] : Test the end-to-end OTA update flow:
            15.3.3.2.7.1. [ ] : Close and reopen the application on the test device/emulator.
            15.3.3.2.7.2. [ ] : Verify that the app detects, downloads, and applies the update. Confirm the visual change is visible.
            15.3.3.2.7.3. [ ] : Check the Capgo dashboard (if available) and any client-side logs for status updates or errors related to the update process.
    15.3.3.3. [ ] **: Basic Error Handling & Fallback Considerations** (Risk: 4/10) (Complexity: 3/10)
        15.3.3.3.1. [ ] : Implement basic error handling for the Capgo update process within the app. This should include logging errors and potentially notifying the user if an update fails critically, while ensuring the app remains functional with the currently installed bundle. (Risk: 4/10) (Complexity: 3/10)
        15.3.3.3.2. [ ] : Review Capgo documentation regarding its handling of native code changes. Confirm that OTA updates are restricted to web assets and that there are safeguards or warnings if native changes are inadvertently included in an update bundle. (Risk: 3/10) (Complexity: 2/10)
    15.3.3.4. [ ] **: Documentation & CI/CD Planning (Initial)** (Risk: 3/10) (Complexity: 3/10)
        15.3.3.4.1. [ ] : Document the manual Capgo setup, build, and upload process, including CLI commands used and Capgo channel strategy.
        15.3.3.4.2. [ ] : (If time allows within Post-MVP scope) Begin outlining the steps to integrate the `@capgo/cli bundle upload` command into the CI/CD pipeline (e.g., GitHub Actions) for the `develop` branch.
            15.3.3.4.2.1. [ ] : Identify necessary CI steps: checkout code, setup Node/Bun, install dependencies, build Next.js static assets, then upload the `out` directory to the appropriate Capgo channel.
            15.3.3.4.2.2. [ ] : Plan for secure storage and usage of the Capgo CLI token within the CI environment.

## Phase 3: Advanced Features & Monetization (Future) - Placeholder (Risk: 8/10 - High complexity, business validation, new large features) (Complexity: 8/10 - Significant new feature sets with business and technical challenges)
P3.0. [ ] **Umbrella Task:** Oversee Phase 3 development. (Risk: 8/10) (Complexity: 3/10 - High-level coordination of complex phase)

### 16. Truck Owner Portal (Risk: 7/10) (Complexity: 7/10 - Building a distinct user-facing application with backend interactions, RBAC, and data management for owners)
16.0. [ ] **Umbrella Task:** Oversee Truck Owner Portal development. (Risk: 7/10) (Complexity: 3/10 - Coordination)
16.1. [ ] **Action:** Develop a separate portal (or distinct section within the main app) for food truck owners to manage their profiles, schedules, and menus. (Risk: 7/10) (Complexity: 8/10 - Involves UI/UX design, RBAC, and dedicated backend logic for owner-specific operations)
    16.1.1. [ ] : Architectural decision: Determine if the owner portal will be a completely separate web application, a distinct route/module within the existing Next.js app, or leverage a multi-project Firebase setup. (Risk: 5/10) (Complexity: 4/10)
        16.1.1.1. [ ] : Evaluate pros and cons: Single project simplifies Auth and data sharing but requires careful routing and UI separation. Separate project offers more isolation but adds complexity for shared users/data.
        16.1.1.2. [ ] : Default to a distinct section/routes within the single Next.js application using the same Firebase project, unless strong justification for separation arises.
    16.1.2. [ ] : Implement Role-Based Access Control (RBAC) using Firebase Authentication custom claims to differentiate truck owners from regular users. (Risk: 6/10) (Complexity: 6/10)
        16.1.2.1. [ ] : Define a custom claim (e.g., `isTruckOwner: true` or `role: 'owner'`).
        16.1.2.2. [ ] : Develop a secure mechanism (e.g., an admin-triggered Cloud Function, or a verified sign-up process for owners) to set this custom claim on designated user accounts using the Firebase Admin SDK.
        16.1.2.3. [ ] : Client-side (owner portal) logic to check for this claim in the user's ID token to grant access to portal features.
        16.1.2.4. [ ] : Update Firestore security rules to leverage this custom claim for owner-specific data access (e.g., only an owner can write to their truck's profile).
        16.1.2.5. [ ] : Be aware of ID token caching (up to 1 hour) and its effect on claim propagation.
    16.1.3. [ ] : Design UI/UX for the owner dashboard and management sections (profile, schedule, menu). (Risk: 5/10) (Complexity: 4/10)
    16.1.4. [ ] : Implement basic dashboard layout and navigation for the owner portal. (Risk: 4/10) (Complexity: 4/10)
16.2. [ ] **Action:** Implement owner management features (profile, schedules, menus) with secure CRUD operations and robust data validation. (Risk: 7/10) (Complexity: 7/10 - Requires careful implementation of forms, data handling, client-side validation, and server-side security rule enforcement for each data type)
    16.2.1. [ ] : Implement CRUD operations for Truck Profile management by authenticated owners. (Risk: 5/10) (Complexity: 5/10)
        16.2.1.1. [ ] : Design and implement forms for creating/editing truck profile details (name, description, cuisine types, banner image, contact info).
        16.2.1.2. [ ] : Implement client-side validation for profile form inputs.
        16.2.1.3. [ ] : Ensure Firestore security rules allow only the authenticated owner (via custom claim `isTruckOwner: true` and matching `userId` to truck's owner field) to create, update, or delete their own truck profile.
        16.2.1.4. [ ] : Implement `.validate` rules in Firestore security rules for truck profile data (e.g., required fields, data types, string lengths).
    16.2.2. [ ] : Implement CRUD operations for Truck Schedules management by authenticated owners. (Risk: 6/10) (Complexity: 6/10 - Managing potentially recurring events, locations, times)
        16.2.2.1. [ ] : Design and implement UI for adding, editing, and deleting schedule entries (date, start/end times, location - potentially linking to a map interface or address input with geocoding).
        16.2.2.2. [ ] : Consider UI for managing recurring schedules if applicable.
        16.2.2.3. [ ] : Implement client-side validation for schedule inputs.
        16.2.2.4. [ ] : Ensure Firestore security rules allow only the authenticated owner to manage schedules for their own truck(s).
        16.2.2.5. [ ] : Implement `.validate` rules for schedule data (e.g., valid dates, times, location format).
    16.2.3. [ ] : Implement CRUD operations for Truck Menu management by authenticated owners. (Risk: 5/10) (Complexity: 6/10 - Handling menu items, categories, prices, descriptions, potentially images)
        16.2.3.1. [ ] : Design and implement UI for managing menu categories and items (name, description, price, image URL).
        16.2.3.2. [ ] : Implement client-side validation for menu item inputs.
        16.2.3.3. [ ] : Ensure Firestore security rules allow only the authenticated owner to manage menus for their own truck(s).
        16.2.3.4. [ ] : Implement `.validate` rules for menu data.
    16.2.4. [ ] : Provide clear user feedback (success/error messages, loading states) for all CRUD operations. (Risk: 3/10) (Complexity: 2/10)

### 17. Advanced Analytics & Reporting (Risk: 5/10) (Complexity: 6/10 - Setting up analytics, defining events, and potentially custom data visualization)
17.1. [ ] **Action:** Integrate Plausible Analytics for privacy-focused web analytics. (Risk: 4/10) (Complexity: 4/10 - Initial setup and pageview tracking)
    17.1.1. [ ] : Set up a Plausible Analytics account and configure the domain. (Risk: 2/10) (Complexity: 1/10)
    17.1.2. [ ] : Integrate Plausible into the Next.js app (e.g., using `next-plausible` package or manually adding script) for basic pageview tracking. (Risk: 3/10) (Complexity: 3/10)
    17.1.3. [ ] : Define and implement 3-5 key custom event tracking goals in Plausible to measure meaningful user interactions, leveraging `next-plausible`. (Risk: 5/10) (Complexity: 5/10 - Requires careful event definition, implementation using `usePlausible` hook, dashboard goal configuration, and thorough testing)
        17.1.3.1. [ ] : Confirm `PlausibleProvider` from `next-plausible` is correctly set up in the root layout (`src/app/layout.tsx`). (Risk: 2/10) (Complexity: 1/10 - Prerequisite check)
        17.1.3.2. [ ] : Identify 3-5 key user interactions for custom event tracking. Examples:
            *   `TruckFavorited`: When a user favorites/unfavorites a truck. Props: `{ truckId: string, favorited: boolean }`.
            *   `FilterApplied`: When a user applies a filter. Props: `{ filterType: string, filterValue: string }` (e.g., `{ filterType: 'cuisine', filterValue: 'Mexican' }`).
            *   `DirectionsClicked`: When a user clicks a "get directions" link/button. Props: `{ truckId: string, truckName: string }`.
            *   `ShareClicked`: When a user clicks a share button. Props: `{ truckId?: string, pageUrl: string }`.
            *   `OutboundLinkClick`: For clicks on external links (e.g., truck's website). Props: `{ url: string, linkContext: string }` (e.g., `linkContext: 'truck_card_website_link'`).
            *   (Consider) `SearchPerformed`: When a user executes a search. Props: `{ searchTerm: string, resultCount: number }`.
        17.1.3.3. [ ] : For each identified custom event:
            17.1.3.3.1. [ ] : Define a clear event name (e.g., `TruckFavorited`, `ApplyFilter`).
            17.1.3.3.2. [ ] : Define relevant custom properties (props) to send with the event for detailed analysis. Keep props concise and meaningful.
            17.1.3.3.3. [ ] : (Optional but recommended) If using TypeScript, define types for custom event names and their props for type safety, as shown in `next-plausible` documentation.
        17.1.3.4. [ ] : Implement custom event tracking in the relevant React components or event handlers using the `usePlausible` hook. (Risk: 4/10) (Complexity: 4/10)
            17.1.3.4.1. [ ] : Example: `const plausible = usePlausible(); plausible('TruckFavorited', { props: { truckId: '123', favorited: true } });`
            17.1.3.4.2. [ ] : For form submissions (if any are tracked as custom events, e.g., a newsletter signup form), ensure tracking is robust. Plausible docs suggest tagging the `<form>` element itself (e.g., `plausible-event-name="NewsletterSignup"`) if the form submission causes navigation, to ensure the event is sent. Alternatively, trigger the event via `usePlausible` in the form's `onSubmit` handler *before* navigation or submission logic that might interrupt the event.
        17.1.3.5. [ ] : In the Plausible Analytics dashboard:
            17.1.3.5.1. [ ] : Ensure "Custom events" feature is enabled for the site under settings.
            17.1.3.5.2. [ ] : For each custom event name implemented, configure it as a "Goal" in the "Goal Conversions" section of the Plausible dashboard.
        17.1.3.6. [ ] : Thoroughly test custom event tracking:
            17.1.3.6.1. [ ] : Trigger each custom event in the application.
            17.1.3.6.2. [ ] : Verify that the event and its associated props appear correctly in the Plausible dashboard (may take a few minutes to show up).
            17.1.3.6.3. [ ] : Check browser console for any errors related to Plausible event tracking.
            17.1.3.6.4. [ ] : If using `trackLocalhost` with `next-plausible` for development, verify events on localhost. Otherwise, test on a staging/preview deployment.
        17.1.3.7. [ ] : Document the implemented custom events, their props, and corresponding Goal names in Plausible. (Risk: 2/10) (Complexity: 2/10)
17.2. [ ] **Action:** Develop custom dashboards or reports if Plausible's default dashboard and goal tracking are insufficient for key performance indicators (KPIs). (Risk: 6/10) (Complexity: 7/10 - Involves API integration, data processing, and visualization if custom solution is built)
    17.2.1. [ ] : Identify key performance indicators (KPIs) for the application (e.g., user engagement, feature adoption, conversion rates for key actions like favoriting or getting directions). (Risk: 4/10) (Complexity: 3/10)
        17.2.1.1. [ ] : Examples: Daily/Monthly Active Users, Top Viewed Trucks, Filter Usage Frequency, Favorite Action Rate, Directions Click Rate.
    17.2.2. [ ] : Evaluate if Plausible's default dashboard and configured custom event goals adequately represent these KPIs. (Risk: 3/10) (Complexity: 2/10)
    17.2.3. [ ] : If custom reporting is needed:
        17.2.3.1. [ ] : Research and understand the Plausible Stats API for data extraction, including available endpoints (e.g., `/api/v1/stats/aggregate`, `/api/v1/stats/timeseries`, `/api/v1/stats/breakdown`), query parameters (e.g., `site_id`, `period`, `metrics`, `filters`, `property`), and authentication (API key in header). (Risk: 4/10) (Complexity: 3/10)
        17.2.3.2. [ ] : Plan the structure and visualizations for the custom report/dashboard. (Risk: 5/10) (Complexity: 4/10)
            17.2.3.2.1. [ ] : Identify 1-2 key KPIs not well covered by Plausible's default dashboard that would benefit from custom visualization (e.g., a specific conversion funnel, detailed breakdown of a custom event by multiple properties).
            17.2.3.2.2. [ ] : Choose a suitable charting library (e.g., Recharts, Chart.js) compatible with Next.js for rendering visualizations.
            17.2.3.2.3. [ ] : Sketch the layout of the custom report/dashboard page.
        17.2.3.3. [ ] : (Potentially Post-MVP) Develop a basic custom report page within the Next.js application. (Risk: 6/10) (Complexity: 6/10 for initial custom report)
            17.2.3.3.1. [ ] : Create a Next.js API route (e.g., `src/app/api/plausible-stats/route.ts`) or a Server Component to securely fetch data from the Plausible Stats API.
                17.2.3.3.1.1. [ ] : Store Plausible API key securely (e.g., environment variable, not exposed client-side).
                17.2.3.3.1.2. [ ] : Construct API requests to Plausible based on the KPIs to be visualized (e.g., specific metrics, filters, time periods).
                17.2.3.3.1.3. [ ] : Handle API responses, including error states.
            17.2.3.3.2. [ ] : Create a client-side React component (or use a Server Component if rendering static charts) to display the fetched data using the chosen charting library.
            17.2.3.3.3. [ ] : Pass data fetched server-side (or via client-side call to the Next.js API route) to the charting components.
            17.2.3.3.4. [ ] : Implement basic UI for the report page (e.g., title, date range selector if applicable, chart containers).
        17.2.3.4. [ ] : Ensure any custom dashboard adheres to data visualization best practices (clarity, simplicity, appropriate chart types for the data, clear labels and legends, accessibility considerations). (Risk: 3/10) (Complexity: 2/10)
        17.2.3.5. [ ] : Document the custom report setup, including API endpoints used, data transformation logic (if any), and chosen visualization methods. (Risk: 2/10) (Complexity: 2/10)

### 18. Monetization Features (Risk: 8/10) (Complexity: 8/10 - Integrating payment systems, handling financial transactions, and business logic)
18.0. [ ] **Umbrella Task:** Oversee Monetization feature planning and implementation. (Risk: 8/10) (Complexity: 3/10 - Coordination)
18.1. [ ] **Action:** Explore and plan for premium truck listings (e.g., featured placement, extended profile options). (Risk: 7/10) (Complexity: 7/10 - Designing the premium feature, payment flow, and backend logic for entitlements)
    18.1.1. [ ] : Define specific features and benefits for premium listings (e.g., top search results, more photos, special badge). (Risk: 4/10) (Complexity: 3/10)
    18.1.2. [ ] : Design UI/UX for showcasing premium listings and the upgrade process for truck owners. (Risk: 4/10) (Complexity: 3/10)
    18.1.3. [ ] : Plan payment integration (Primary: Polar.sh; Fallback: Stripe), including subscription management if applicable. (Risk: 7/10) (Complexity: 7/10 - Integrating payment gateways, handling webhooks, managing subscription states, and ensuring security)
        18.1.3.1. [ ] : **Polar.sh Integration Planning:**
            18.1.3.1.1. [ ] : Research Polar.sh API/SDK, particularly `@polar-sh/nextjs` for checkout and webhook handling. (Risk: 4/10) (Complexity: 3/10)
            18.1.3.1.2. [ ] : Set up Polar.sh account, organization, and define product(s) for premium listings (e.g., one-time payment or subscription tiers). (Risk: 3/10) (Complexity: 3/10)
            18.1.3.1.3. [ ] : Plan Polar.sh Checkout flow:
                18.1.3.1.3.1. [ ] : Implement server-side logic (Next.js API route or Server Action) to initiate checkout using `@polar-sh/nextjs` `Checkout` function, providing access token and `successUrl`. (Risk: 5/10) (Complexity: 4/10)
                18.1.3.1.3.2. [ ] : Design the `successUrl` page to inform user about "confirmation" status, pending final verification via webhook. (Risk: 3/10) (Complexity: 2/10)
            18.1.3.1.4. [ ] : Plan Polar.sh Webhook handling:
                18.1.3.1.4.1. [ ] : Create a dedicated Next.js API route for Polar webhooks. (Risk: 3/10) (Complexity: 3/10)
                18.1.3.1.4.2. [ ] : Implement webhook signature validation (base64 encode Polar secret if validating manually). (Risk: 5/10) (Complexity: 4/10)
                18.1.3.1.4.3. [ ] : Handle `checkout.updated` event with `status: succeeded` to confirm payment and grant premium features/entitlements. (Risk: 6/10) (Complexity: 5/10)
                18.1.3.1.4.4. [ ] : Implement asynchronous processing for webhook handler (respond quickly, offload heavy logic). (Risk: 4/10) (Complexity: 3/10)
                18.1.3.1.4.5. [ ] : Plan for handling other relevant events (e.g., `subscription.updated`, `benefit.granted`). (Risk: 4/10) (Complexity: 3/10)
                18.1.3.1.4.6. [ ] : Utilize Polar dashboard for monitoring webhook deliveries and troubleshooting. (Risk: 2/10) (Complexity: 1/10)
            18.1.3.1.5. [ ] : Plan Firestore schema updates to store premium status/entitlements for trucks/owners. (Risk: 3/10) (Complexity: 3/10)
        18.1.3.2. [ ] : **Stripe Integration Planning (Fallback):**
            18.1.3.2.1. [ ] : Research Stripe API/SDK, focusing on Stripe Checkout or Stripe Elements for Next.js. (Risk: 4/10) (Complexity: 3/10)
            18.1.3.2.2. [ ] : Set up Stripe account, define product(s) and price(s) for premium listings. (Risk: 3/10) (Complexity: 3/10)
            18.1.3.2.3. [ ] : Plan Stripe Checkout flow:
                18.1.3.2.3.1. [ ] : Implement server-side logic (Next.js API route or Server Action) to create a Stripe Checkout Session. (Risk: 5/10) (Complexity: 4/10)
                18.1.3.2.3.2. [ ] : Redirect client to Stripe-hosted checkout page or integrate Stripe Elements. (Risk: 4/10) (Complexity: 4/10)
                18.1.3.2.3.3. [ ] : Design `success_url` and `cancel_url` pages. (Risk: 3/10) (Complexity: 2/10)
            18.1.3.2.4. [ ] : Plan Stripe Webhook handling:
                18.1.3.2.4.1. [ ] : Create a dedicated Next.js API route for Stripe webhooks. Configure `api: { bodyParser: false }`. (Risk: 4/10) (Complexity: 4/10)
                18.1.3.2.4.2. [ ] : Implement webhook signature verification using `stripe.webhooks.constructEvent` and `STRIPE_WEBHOOK_SECRET`. (Risk: 5/10) (Complexity: 4/10)
                18.1.3.2.4.3. [ ] : Handle `checkout.session.completed` and/or `payment_intent.succeeded` events to confirm payment and grant premium features. (Risk: 6/10) (Complexity: 5/10)
                18.1.3.2.4.4. [ ] : Implement asynchronous processing for webhook handler. (Risk: 4/10) (Complexity: 3/10)
                18.1.3.2.4.5. [ ] : Plan for handling other relevant events (e.g., `customer.subscription.updated`, `invoice.payment_failed`). (Risk: 4/10) (Complexity: 3/10)
            18.1.3.2.5. [ ] : Ensure secure handling of Stripe API keys and webhook secrets (environment variables). (Risk: 3/10) (Complexity: 2/10)
            18.1.3.2.6. [ ] : Plan Firestore schema updates for Stripe-related data (e.g., `stripeCustomerId`, `subscriptionId`). (Risk: 3/10) (Complexity: 3/10)
18.2. [ ] **Action:** Investigate in-app advertising models (e.g., non-intrusive ads for standard listings, ad-free for premium users/listings). (Risk: 6/10) (Complexity: 6/10 - Researching ad networks, SDK/plugin integration, UI/UX considerations for ad placement, ethical implications, and performance impact)
    18.2.1. [ ] : Research ad networks suitable for Next.js web applications and Capacitor mobile apps. (Risk: 5/10) (Complexity: 4/10)
        18.2.1.1. [ ] : Evaluate Google AdMob (popular for mobile, Capacitor plugins available) for the Capacitor app. (Risk: 4/10) (Complexity: 3/10)
        18.2.1.2. [ ] : Evaluate Google AdSense for the Next.js web application. (Risk: 3/10) (Complexity: 2/10)
        18.2.1.3. [ ] : Research ethical ad networks that prioritize user privacy and experience (e.g., Carbon Ads, EthicalAds). (Risk: 4/10) (Complexity: 3/10)
        18.2.1.4. [ ] : Compare networks based on revenue models, ad quality, targeting capabilities, ease of integration, and developer policies. (Risk: 3/10) (Complexity: 2/10)
    18.2.2. [ ] : Plan ad placement, formats, and frequency, prioritizing user experience. (Risk: 5/10) (Complexity: 4/10)
        18.2.2.1. [ ] : Identify non-intrusive locations for ads (e.g., banner at bottom of list views, native ads within list items, interstitial ads during natural pauses like after a search or filter action but not excessively). (Risk: 4/10) (Complexity: 3/10)
        18.2.2.2. [ ] : Define ad formats to test (e.g., banners, native ads, rewarded ads if applicable for certain user actions  though less likely for this app type). (Risk: 3/10) (Complexity: 2/10)
        18.2.2.3. [ ] : Establish frequency capping rules to avoid overwhelming users. (Risk: 3/10) (Complexity: 2/10)
        18.2.2.4. [ ] : Consider offering an ad-free experience for premium users/listings as a value proposition. (Risk: 2/10) (Complexity: 2/10)
    18.2.3. [ ] : Plan for technical integration of the chosen ad SDK/plugin. (Risk: 4/10) (Complexity: 4/10)
        18.2.3.1. [ ] : For Capacitor/AdMob, plan integration of the community AdMob plugin. (Risk: 4/10) (Complexity: 3/10)
        18.2.3.2. [ ] : For Next.js/AdSense (or other web ad networks), plan script integration, considering Next.js specific contexts (e.g., using `next/script`). (Risk: 3/10) (Complexity: 3/10)
    18.2.4. [ ] : Document ethical considerations and compliance requirements (e.g., GDPR, CCPA regarding data for ads, clear ad labeling). (Risk: 4/10) (Complexity: 3/10)
18.3. [ ] **Action:** Plan for data insights as a revenue stream (e.g., aggregated, anonymized trend data for businesses, researchers, or local planning). (Risk: 7/10) (Complexity: 8/10 - Requires robust data aggregation, strong anonymization techniques, sophisticated analysis, secure data handling and presentation, a clear value proposition, and navigating significant privacy/ethical considerations)
    18.3.1. [ ] : Identify 2-3 potential valuable data insights that can be ethically derived and offered (e.g., popular cuisine trends by generalized area/time, peak operating hour clusters, general foot traffic patterns near truck locations, effectiveness of certain promotions if data is available). (Risk: 5/10) (Complexity: 4/10 - Requires creative thinking and understanding of market needs)
    18.3.2. [ ] : Define robust data anonymization and aggregation strategy. (Risk: 7/10) (Complexity: 6/10 - Technical implementation of anonymization is critical)
        18.3.2.1. [ ] : Research and select appropriate anonymization techniques (e.g., k-anonymity, l-diversity, t-closeness, differential privacy if feasible). (Risk: 6/10) (Complexity: 5/10)
        18.3.2.2. [ ] : Ensure all personally identifiable information (PII) is removed or irreversibly masked (e.g., exact user IDs, precise geolocations of users). Generalize sensitive data (e.g., locations to broader regions/neighborhoods, times to broader windows). (Risk: 5/10) (Complexity: 4/10)
        18.3.2.3. [ ] : Plan for data aggregation to provide summary statistics rather than individual data points (e.g., "X% of trucks in downtown serve Y cuisine on weekends" vs. individual truck data). (Risk: 4/10) (Complexity: 3/10)
        18.3.2.4. [ ] : Implement processes to regularly review and test the effectiveness of anonymization against potential re-identification attacks. (Risk: 5/10) (Complexity: 4/10)
    18.3.3. [ ] : Outline the packaging, pricing (if applicable), and delivery mechanism for these data insights (e.g., periodic reports, API access to anonymized/aggregated data, custom dashboards for subscribers). (Risk: 5/10) (Complexity: 4/10)
    18.3.4. [ ] : Develop clear policies on data governance, transparency, and user consent regarding the use of aggregated data for insights. (Risk: 6/10) (Complexity: 4/10)
        18.3.4.1. [ ] : Update Privacy Policy to clearly explain how anonymized and aggregated data may be used for insights and commercial purposes. (Risk: 4/10) (Complexity: 3/10)
        18.3.4.2. [ ] : Consider providing users with opt-out choices if their non-PII data contributes to aggregates, or ensure the anonymization is so robust that opt-out is not strictly necessary from a privacy standpoint. (Risk: 4/10) (Complexity: 3/10)
    18.3.5. [ ] : Plan for secure data storage, processing, and access controls for the aggregated insight datasets. (Risk: 5/10) (Complexity: 4/10)
    18.3.6. [ ] : Evaluate legal and ethical implications, ensuring compliance with relevant data privacy regulations (e.g., GDPR, CCPA). (Risk: 6/10) (Complexity: 4/10)

This WBS provides a detailed, fractal breakdown of the entire development process, from foundational setup to advanced features, with clear actions and checklist placeholders.
